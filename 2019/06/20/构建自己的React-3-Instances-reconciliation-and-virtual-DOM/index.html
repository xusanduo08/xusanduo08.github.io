<!DOCTYPE html><html lang="中文"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 构建自己的React(3):Instances,reconciliation and virtual DOM · Neo</title><meta name="description" content="虚拟DOM一致性比较 节点更新"><meta name="viewport" content="width=device-width, initial-scale=1"><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="HandheldFriendly" content="True"><meta name="MobileOptimized" content="320"><meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0, maximum-scale=1, user-scalable=no, minimal-ui"><meta name="keywords" content="节点更新 一致性比较 reconciliation"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="apple-touch-icon" href="2048/meta/apple-touch-icon.png"><link rel="apple-touch-startup-image" href="2048/meta/apple-touch-startup-image-640x1096.png" media="(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2)"><link rel="apple-touch-startup-image" href="2048/meta/apple-touch-startup-image-640x920.png" media="(device-width: 320px) and (device-height: 480px) and (-webkit-device-pixel-ratio: 2)"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-146300475-1"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date())

gtag('config', 'UA-146300475-1')
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?cfd774e7572f024fbb235d52afbd4103";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script><link rel="search" type="application/opensearchdescription+xml" href="http://mengfansheng.com/atom.xml" title="Neo"><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Neo" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://segmentfault.com/a/1190000017234428" target="_blank" class="nav-list-link">SEGMENGFAULT</a></li><li class="nav-list-item"><a href="https://github.com/xusanduo08" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/2048/" target="_self" class="nav-list-link">GAMES</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">构建自己的React(3):Instances,reconciliation and virtual DOM</h1><div class="post-info">Jun 20, 2019</div><div class="post-content"><p>翻译自这里：<a target="_blank" rel="noopener" href="https://engineering.hexacta.com/didact-instances-reconciliation-and-virtual-dom-9316d650f1d0">https://engineering.hexacta.com/didact-instances-reconciliation-and-virtual-dom-9316d650f1d0</a></p>
<h4 id="Didact-Instances-reconciliation-and-virtual-DOM"><a href="#Didact-Instances-reconciliation-and-virtual-DOM" class="headerlink" title="Didact:Instances, reconciliation and virtual DOM"></a>Didact:Instances, reconciliation and virtual DOM</h4><p>截止目前我们已经可以使用JSX来创建并渲染页面DOM。在这一节我们将会把重点放在如何更新DOM上。</p>
<p>在介绍<code>setState</code>之前，更新DOM只能通过更改入参并再次调用<code>render</code>方法来实现。如果我们想实现一个时钟，代码大概下面这个样子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> rootDom = <span class="built_in">document</span>.getElementById(<span class="string">&quot;root&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> time = <span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleTimeString();</span><br><span class="line">  <span class="keyword">const</span> clockElement = <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;time&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">  render(clockElement, rootDom);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tick();</span><br><span class="line"><span class="built_in">setInterval</span>(tick, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<p>事实上，上面的代码运行后并不能达到预期的效果，多次调用当前版本的<code>render</code>方法只会不断往页面上添加新的元素，而不是我们预期的更新已经存在的元素。下面我们想办法实现更新操作。在<code>render</code>方法末尾，我们可以去检查父类元素是否含有子元素，如果有，我们就用新生成的元素去替换旧的元素。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">element, parentDom</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// Create dom from element</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span>(!parentDom.lastChild)&#123;</span><br><span class="line">        parentDom.appendChild(dom);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        parentDom.replaceChild(dom, parentDom.lastChild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>针对开头那个时钟的例子，上面<code>render</code>的实现是没问题的。但对于更复杂的情况，比如有多个子元素时上面代码就不能满足要求了。正确的做法是我们需要比较前后两次调用<code>render</code>方法时所生成的元素树，对比差异后只更新有变化的部分。</p>
<h4 id="Virtual-DOM-and-Reconciliation"><a href="#Virtual-DOM-and-Reconciliation" class="headerlink" title="Virtual DOM and Reconciliation"></a>Virtual DOM and Reconciliation</h4><p>React把一致性校验的过程称作“diffing”，我们要做的和React一样。首先需要把当前的元素树保存起来以便和后面新的元素树比较，也就是说，我们需要把当前页面内容所对应的虚拟DOM保存下来。</p>
<p>这颗虚拟DOM树的节点有必要讨论一下。一种选择是使用Didact Elements，它们已经含有<code>props.children</code>属性，我们可以根据这个属性构建出虚拟DOM树。现在有两个问题摆在面前：首先，为了方便比较，我们需要保存每个虚拟DOM指向的真实DOM的引用（校验过程中我们有需要会去更新实际DOM的属性），并且元素还要是不可变的；第二，目前元素还不支持含有内部状态（state）的组件。</p>
<h4 id="Instances"><a href="#Instances" class="headerlink" title="Instances"></a>Instances</h4><p>我们需要引入一个新的概念—–instances—–来解决上面的问题。一个实例表示一个已经渲染到DOM的元素，它是含有<code>element</code>，<code>dom</code>和<code>childInstances</code>属性的一个JS对象。<code>childInstances</code>是由子元素对应实例组成的数组。</p>
<blockquote>
<p>注意，这里说的实例和Dan Abramov在<a target="_blank" rel="noopener" href="https://medium.com/@dan_abramov/react-components-elements-and-instances-90800811f8ca">React Components, Elements, and Instances</a>中提到的实例并不是一回事。Dan说的是公共实例，是调用继承自<code>React.Component</code>的组件的构造函数后返回的东西。我们将在后面的章节添加公共实例。</p>
</blockquote>
<p>每个DOM节点都会有对应的实例。一致性校验的目的之一就是尽量避免去创建或者移除实例。创建和移除实例意味着我们要修改DOM树，所以我们越多的重用实例就会越少的去修改DOM树。</p>
<h4 id="Refactoring"><a href="#Refactoring" class="headerlink" title="Refactoring"></a>Refactoring</h4><p>接下来我们来重构<code>render</code>方法，增加一致性校验算法，同时增加一个<code>instantiate</code>方法来为元素创建实例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> rootInstance = <span class="literal">null</span>; <span class="comment">// 用来保存上一次调用render产生的实例</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">element, container</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> prevInstance = rootInstance;</span><br><span class="line">    <span class="keyword">const</span> nextInstance = reconcile(container, prevInstance, element);</span><br><span class="line">    rootInstance = nextInstace;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 目前只是针对根元素的校验，没有处理到子元素</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reconcile</span>(<span class="params">parentDom, instance, element</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(instance === <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">const</span> newInstance = instantiate(element);</span><br><span class="line">        parentDom.appendChild(newInstance.dom);</span><br><span class="line">        <span class="keyword">return</span> newInstance;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> newInstance = instantiate(element);</span><br><span class="line">        parentDom.replaceChild(newInstance.dom, instance.dom);</span><br><span class="line">        <span class="keyword">return</span> newInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成元素对应实例的方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">instantiate</span>(<span class="params">element</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; type, props&#125; = element;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> isTextElement = type === <span class="string">&#x27;TEXT_ELEMENT&#x27;</span>;</span><br><span class="line">    <span class="keyword">const</span> dom = isTextElement ? <span class="built_in">document</span>.createTextNode(<span class="string">&#x27;&#x27;</span>) </span><br><span class="line">    	: <span class="built_in">document</span>.createElement(type);</span><br><span class="line">    	</span><br><span class="line">    <span class="comment">// 添加事件</span></span><br><span class="line">    <span class="keyword">const</span> isListener = <span class="function"><span class="params">name</span> =&gt;</span> name.startsWith(<span class="string">&quot;on&quot;</span>);</span><br><span class="line">    <span class="built_in">Object</span>.keys(props).filter(isListener).forEach(<span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">    	<span class="keyword">const</span> eventType = name.toLowerCase().substring(<span class="number">2</span>);</span><br><span class="line">        dom.addEventListener(eventType, props[name]);</span><br><span class="line">     &#125;);</span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 设置属性</span></span><br><span class="line">  	<span class="keyword">const</span> isAttribute = <span class="function"><span class="params">name</span> =&gt;</span> !isListener(name) &amp;&amp; name != <span class="string">&quot;children&quot;</span>;</span><br><span class="line">  	<span class="built_in">Object</span>.keys(props).filter(isAttribute).forEach(<span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">    	dom[name] = props[name];</span><br><span class="line">  	&#125;);</span><br><span class="line">  	</span><br><span class="line">  	<span class="keyword">const</span> childElements = props.children || [];</span><br><span class="line">  	<span class="keyword">const</span> childInstances = childElements.map(instantiate);</span><br><span class="line">  	<span class="keyword">const</span> childDoms = childInstances.map(<span class="function"><span class="params">childInstance</span> =&gt;</span> childInstace.dom);</span><br><span class="line">  	childDoms.forEach(<span class="function"><span class="params">childDom</span> =&gt;</span> dom.appendChild(childDOm));</span><br><span class="line">  	</span><br><span class="line">  	<span class="keyword">const</span> instance = &#123;dom, element, childInstances&#125;;</span><br><span class="line">  	<span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的<code>render</code>方法和之前的差不多，不同之处是保存了上次调用<code>render</code>方法产生的实例。我们还把一致性校验的功能从创建实例的代码中分离了出来。</p>
<p>为了重用dom节点，我们需要一个能更新dom属性的方法，这样就不用每次都创建新的dom节点了。我们来改造一下现有代码中设置属性的那部分的代码。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">instantiate</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; type, props &#125; = element;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建DOM元素</span></span><br><span class="line">  <span class="keyword">const</span> isTextElement = type === <span class="string">&#x27;TEXT_ELEMENT&#x27;</span>;</span><br><span class="line">  <span class="keyword">const</span> dom = isTextElement</span><br><span class="line">    ? <span class="built_in">document</span>.createTextNode(<span class="string">&quot;&quot;</span>)</span><br><span class="line">    : <span class="built_in">document</span>.createElement(type);</span><br><span class="line"></span><br><span class="line">  updateDomProperties(dom, [], props); <span class="comment">// 实例化一个新的元素</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 实例化并添加子元素</span></span><br><span class="line">  <span class="keyword">const</span> childElements = props.children || [];</span><br><span class="line">  <span class="keyword">const</span> childInstances = childElements.map(instantiate);</span><br><span class="line">  <span class="keyword">const</span> childDoms = childInstances.map(<span class="function"><span class="params">childInstance</span> =&gt;</span> childInstance.dom);</span><br><span class="line">  childDoms.forEach(<span class="function"><span class="params">childDom</span> =&gt;</span> dom.appendChild(childDom));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> instance = &#123; dom, element, childInstances &#125;;</span><br><span class="line">  <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateDomProperties</span>(<span class="params">dom, prevProps, nextProps</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> isEvent = <span class="function"><span class="params">name</span> =&gt;</span> name.startsWith(<span class="string">&#x27;on&#x27;</span>);</span><br><span class="line">   	<span class="keyword">const</span> isAttribute = <span class="function"><span class="params">name</span> =&gt;</span> !isEvent(name) &amp;&amp; name != <span class="string">&#x27;children&#x27;</span>;</span><br><span class="line">   	</span><br><span class="line">   	<span class="built_in">Object</span>.keys(prevProps).filter(isEvent).forEach(<span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> eventType = name.toLowerCase().substring(<span class="number">2</span>);</span><br><span class="line">        dom.removeEventListener(eventType, prevProps[name]);</span><br><span class="line">   	&#125;);</span><br><span class="line">   	</span><br><span class="line">   	<span class="built_in">Object</span>.keys(preProps).filter(isAttribute).forEach(<span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">        dom[name] = nextProps[name];</span><br><span class="line">   	&#125;);</span><br><span class="line">   	</span><br><span class="line">   	<span class="comment">// 设置属性</span></span><br><span class="line">  	<span class="built_in">Object</span>.keys(nextProps).filter(isAttribute).forEach(<span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">    	dom[name] = nextProps[name];</span><br><span class="line">  	&#125;);</span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 添加事件监听</span></span><br><span class="line">  	<span class="built_in">Object</span>.keys(nextProps).filter(isEvent).forEach(<span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">    	<span class="keyword">const</span> eventType = name.toLowerCase().substring(<span class="number">2</span>);</span><br><span class="line">    	dom.addEventListener(eventType, nextProps[name]);</span><br><span class="line">  	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>updateDomProperties</code>方法会移除所有旧的属性，然后再添加新属性。如果属性没有变化的话依然会进行移除和添加操作，这一定程度上有些浪费，但我们先这样放着，后面再处理。</p>
<h4 id="Reusing-DOM-nodes"><a href="#Reusing-DOM-nodes" class="headerlink" title="Reusing DOM nodes"></a>Reusing DOM nodes</h4><p>前面说过，一致性校验算法需要尽可能多的去重用已经创建的节点。因为目前元素的<code>type</code>都是代表HTML中标签名的字符串，所以如果同一位置前后两次渲染的元素的类型一样则表示两者为同一类元素，对应的已经渲染到页面上的dom节点就可以被重用。下面我们在<code>reconcile</code>中增加判断前后两次渲染的元素类型是否相同的功能，相同的话执行更新操作，否则是新建或者替换。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reconcile</span>(<span class="params">parentDom, instance, element</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 创建实例</span></span><br><span class="line">    <span class="keyword">const</span> newInstance = instantiate(element);</span><br><span class="line">    parentDom.appendChild(newInstance.dom);</span><br><span class="line">    <span class="keyword">return</span> newInstance;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (instance.element.type === element.type) &#123; <span class="comment">// 和老的实例进行类型比较</span></span><br><span class="line">    <span class="comment">// 更新</span></span><br><span class="line">    updateDomProperties(instance.dom, instance.element.props, element.props);</span><br><span class="line">    instance.element = element;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果不相等的话直接替换</span></span><br><span class="line">    <span class="keyword">const</span> newInstance = instantiate(element);</span><br><span class="line">    parentDom.replaceChild(newInstance.dom, instance.dom);</span><br><span class="line">    <span class="keyword">return</span> newInstance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Children-Reconciliation"><a href="#Children-Reconciliation" class="headerlink" title="Children Reconciliation"></a>Children Reconciliation</h4><p>现在校验过程还没有对子元素进行处理。针对子元素的校验是React中的一个关键部分，这一过程需要元素的一个额外属性<code>key</code>来完成，如果某个元素在新旧虚拟DOM上的<code>key</code>值相同，则表示该元素没有发生变化，直接重用即可。在当前版本的代码中我们会遍历<code>instance.childInstances</code>和<code>element.props.children</code>，并对同一位置的实例和元素进行比较，通过这种方式完成对子元素的一致性校验。这种方法的缺点就是，如果子元素只是调换了位置，那么对应的DOM节点将没法重用。</p>
<p>我们把同一实例上一次的<code>instance.childInstances</code>和这次对应元素的<code>element.props.children</code>进行递归比较，并且保存每次<code>reconcile</code>返回的结果以便更新<code>childInstances</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reconcile</span>(<span class="params">parentDom, instance, element</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">       <span class="keyword">const</span> newInstance = instantiate(element);</span><br><span class="line">        parentDom.appendChild(newInstance.dom);</span><br><span class="line">        <span class="keyword">return</span> newInstance;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(instance.element.type === element.type)&#123;</span><br><span class="line">        updateDomProperties(instance.dom, instance.element.props, element.props);</span><br><span class="line">        instance.childInstances = reconcileChildren(instance, element);</span><br><span class="line">        instance.element = element;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> newInstance = instantiate(element);</span><br><span class="line">        parentDom.replaceChild(newInstance.dom, instance.dom);</span><br><span class="line">        <span class="keyword">return</span> newInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reconcileChildren</span>(<span class="params">instance, element</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">const</span> dom = instance.dom;</span><br><span class="line">    <span class="keyword">const</span> childInstances = instance.childInstances;</span><br><span class="line">    <span class="keyword">const</span> nextChildElements = element.props.children || [];</span><br><span class="line">    <span class="keyword">const</span> newChildInstances = [];</span><br><span class="line">    <span class="keyword">const</span> count = <span class="built_in">Math</span>.max(childInstances.length, nextChildElements.length);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i&lt; count; i++)&#123;</span><br><span class="line">        <span class="keyword">const</span> childInstance = childInstances[i]; </span><br><span class="line">        <span class="keyword">const</span> childElement = nextChildElements[i];<span class="comment">//上面一行和这一行都容易出现空指针，稍后处理</span></span><br><span class="line">        <span class="keyword">const</span> newChildInstance = reconcile(dom, childInstance, childElement);</span><br><span class="line">        newChildInstances.push(newChildInstance);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newChildInstances;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Removing-DOM-nodes"><a href="#Removing-DOM-nodes" class="headerlink" title="Removing DOM nodes"></a>Removing DOM nodes</h4><p>如果<code>nextChildElements</code>数量多于<code>childInstances</code>，那么对子元素进行一致性校验时就容易出现<code>undefined</code>与剩下的子元素进行比较的情况。不过这不是什么大问题，因为在<code>reconcile</code>中的<code>if(instance == null)</code>会处理这种情况，并且会根据多出来的元素创建新的实例。如果<code>childInstances</code>的数量多于<code>nextChildElement</code>，那么<code>reconcile</code>就会收到一个<code>undefined</code>作为其<code>element</code>参数，然后在尝试获取<code>element.type</code>时就会抛出错误。</p>
<p>出现这个错误是因为我们没有考虑DOM节点需要移除的情况。所以接下来我们要做两件事情，一个是在<code>reconcile</code>中增加增加<code>element === null</code>的校验，一个是在<code>reconcileChildren</code>中过滤掉值为<code>null</code>的<code>childInstances</code>元素。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reconcile</span>(<span class="params">parentDom, instance, element</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">const</span> newInstance = instantiate(element);</span><br><span class="line">        parentDom.appendChild(newInstance.dom);</span><br><span class="line">        <span class="keyword">return</span> Instance;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(element == <span class="literal">null</span>)&#123;</span><br><span class="line">        parentDom.removeChild(instance.dom);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 注意这地方返回null了</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(instance.element.type === element.type)&#123;</span><br><span class="line">        updateDomProperties(instance.dom, instance.element.props, element.props);</span><br><span class="line">        instance.childInstances = reconcileChildren(instance, element);</span><br><span class="line">        instance.element = element;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> newInstance = instantiate(element);</span><br><span class="line">        parentDom.replaceChild(newInstance.dom, instance.dom);</span><br><span class="line">        <span class="keyword">return</span> newInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reconcileChildren</span>(<span class="params">instance, element</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> dom = instance.dom;</span><br><span class="line">    <span class="keyword">const</span> childInstances = instance.childInstances;</span><br><span class="line">    <span class="keyword">const</span> nextChildElements = element.props.children || [];</span><br><span class="line">    <span class="keyword">const</span> newChildInstances = [];</span><br><span class="line">    <span class="keyword">const</span> count = <span class="built_in">Math</span>.max(childInstances.length, nextChildElements.length);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; count; i++)&#123;</span><br><span class="line">        <span class="keyword">const</span> childInstance = childInstances[i];</span><br><span class="line">        <span class="keyword">const</span> childElement = nextChildElements[i];</span><br><span class="line">        <span class="keyword">const</span> newChildInstances = reconcile(dom, childInstance, childElement);</span><br><span class="line">        newChildInstances.push(newChildInstance);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newChildInstances.filter(<span class="function"><span class="params">instance</span> =&gt;</span> instance != <span class="literal">null</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h4><p>这一节，我们为Didact增加了更新DOM的功能。我们通过重用节点，避免了频繁的创建和移除DOM节点，提高了Didact的工作效率。重用节点还有一定的好处，比如保存了DOM的位置或者焦点等一些内部状态信息。</p>
<p>目前我们是在根元素上调用<code>render</code>方法的，每次有变化时也是针对整棵元素树进行的一致性校验。<a target="_blank" rel="noopener" href="https://engineering.hexacta.com/didact-components-and-state-53ab4c900e37">下一节</a>我们将介绍组件。有了组件我们就可以只针对有变化的那一部分子树进行一致性校验。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2019/06/25/%E6%9E%84%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84React-2-Element-creation-and-JSX-md/" class="prev">上一篇</a><a href="/2019/06/16/%E6%9E%84%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84React-4-Components-and-State/" class="next">下一篇</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'seansun';
var disqus_identifier = '2019/06/20/构建自己的React-3-Instances-reconciliation-and-virtual-DOM/';
var disqus_title = '构建自己的React(3):Instances,reconciliation and virtual DOM';
var disqus_url = 'http://mengfansheng.com/2019/06/20/构建自己的React-3-Instances-reconciliation-and-virtual-DOM/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//seansun.disqus.com/count.js" async></script><div class="copyright"><p>© 2015 - 2021 <a href="http://mengfansheng.com">孟凡胜</a>, <a href="http://www.beian.miit.gov.cn" target="_blank">苏ICP备17022623号</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>