<!DOCTYPE html><html lang="中文"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 构建自己的React:Didact fiber · Neo</title><meta name="description" content="react-fiber解析 构建自己的react-fiber 构建自己的react react fiber"><meta name="viewport" content="width=device-width, initial-scale=1"><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="HandheldFriendly" content="True"><meta name="MobileOptimized" content="320"><meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0, maximum-scale=1, user-scalable=no, minimal-ui"><meta name="keywords" content="react-fiber 构建自己的react-fiber 异步渲染 fiber"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="apple-touch-icon" href="2048/meta/apple-touch-icon.png"><link rel="apple-touch-startup-image" href="2048/meta/apple-touch-startup-image-640x1096.png" media="(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2)"><link rel="apple-touch-startup-image" href="2048/meta/apple-touch-startup-image-640x920.png" media="(device-width: 320px) and (device-height: 480px) and (-webkit-device-pixel-ratio: 2)"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-146300475-1"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date())

gtag('config', 'UA-146300475-1')
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?cfd774e7572f024fbb235d52afbd4103";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script><link rel="search" type="application/opensearchdescription+xml" href="http://mengfansheng.com/atom.xml" title="Neo"><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Neo" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://segmentfault.com/a/1190000017234428" target="_blank" class="nav-list-link">SEGMENGFAULT</a></li><li class="nav-list-item"><a href="https://github.com/xusanduo08" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/2048/" target="_self" class="nav-list-link">GAMES</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">构建自己的React:Didact fiber</h1><div class="post-info">Dec 12, 2018</div><div class="post-content"><p>翻译自这里：<a target="_blank" rel="noopener" href="https://engineering.hexacta.com/didact-fiber-incremental-reconciliation-b2fe028dcaec">https://engineering.hexacta.com/didact-fiber-incremental-reconciliation-b2fe028dcaec</a></p>
<p>React16已经发布了，其内部重写了很多代码，内部结构也发生了一些变化，有一些新的特性也随之推出。我们在之前系列里写的代码多多少少有些过时了。在这一节，我们将会根据React16的最新结构来重写大部分的代码，代码结构和变量命名我们也会尽量按照React16的来。我们的代码暴露了一下几个API：</p>
<ul>
<li><code>Didact.createElement</code></li>
<li><code>Didact.render()</code>（用来DOM渲染）</li>
<li><code>Didact.Component</code>(带有<code>setState()</code>，但没有<code>context</code>及其他生命周期方法)</li>
</ul>
<p>以上API不需要的东西我们不会涉及。</p>
<p>如果你想直接看代码及运行效果，可以看<a target="_blank" rel="noopener" href="https://codepen.io/pomber/pen/veVOdd">这里</a>，或者访问<a target="_blank" rel="noopener" href="https://github.com/pomber/didact">代码库</a>。</p>
<p>好了，先来解释下以前的代码为什么需要重写。</p>
<h4 id="Why-Fiber"><a href="#Why-Fiber" class="headerlink" title="Why Fiber"></a>Why Fiber</h4><blockquote>
<p>我们不会解释的很详细，如果你想具体了解，可以看一下这个<a target="_blank" rel="noopener" href="https://github.com/koba04/react-fiber-resources">list</a></p>
</blockquote>
<p>当浏览器的主线程一直被某一任务占用时，其他任务就无法去执行，直到占用主线程的任务完成，其他任务才有可能被执行。</p>
<p>我做了一个<a target="_blank" rel="noopener" href="https://pomber.github.io/incremental-rendering-demo/react-sync.html">demo</a>来展示上面提到的问题。为了保持星球的持续转动，主线程至少每隔16ms就需要空闲出来以渲染页面。假如主线程一直被其他任务占用，比如占用了200ms，你就会发现动画有一些丢帧（通俗的说就是卡顿），在主线程被占用时星球会停着不动。</p>
<p>那么是什么一直占用着主线程，使得主线程无法去执行渲染任务以至于页面有卡顿呢？</p>
<p>还记得我们写的<a target="_blank" rel="noopener" href="https://engineering.hexacta.com/didact-instances-reconciliation-and-virtual-dom-9316d650f1d0">一致性校验的代码</a>么？一旦开始一致性校验，过程就不会停止。此时，如果其他任务需要执行，那么只有排队等待。而且，因为一致性校验是一个递归的规程，所以很难暂停。接下来我们将会使用一种新的数据结构来重写一致性校验的代码，并用循环来代替递归。</p>
<h4 id="Scheduling-micro-tasks"><a href="#Scheduling-micro-tasks" class="headerlink" title="Scheduling micro-tasks"></a>Scheduling micro-tasks</h4><p>我们需要把__任务__分割成更细小的__任务片__，以单位任务片的方式来执行这些任务，在执行的间隙，主线程可以去执行有更高优先级的其他任务，结束之后再回来继续执行剩余的任务片。</p>
<p>我们将定义一个<code>requestIdleCallback()</code>方法来完成上述功能。这个方法会维护一个回调，这个回调是下次浏览器空闲时需要去执行的任务。在执行这个回调时还会传入一个<code>deadline</code>参数，用来描述当前有多少时间可以用来执行这个任务。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ENOUGH_TIME = <span class="number">1</span>; <span class="comment">// 毫秒</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> workQueue = [];</span><br><span class="line"><span class="keyword">let</span> nextUnitOfWork = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">schedule</span>(<span class="params">task</span>)</span>&#123;</span><br><span class="line">    workQueue.push(task);</span><br><span class="line">    requestIdleCallback(performWork);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">performWork</span>(<span class="params">deadline</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!nextUnitOfWork)&#123;</span><br><span class="line">       nextUnitOfWork = workQueue.shift();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(nextUnitOfWork &amp;&amp; deadline.timeRemaining() &gt; ENOUGH_TIME )&#123;</span><br><span class="line">        nextUnitOfWork = performUnitOfWork(nextUnitOfWork);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(nextUnitOfWork || workQueue.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        requestIdleCallback(performWork);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>真正执行任务的是<code>performUnitOfWork</code>这个方法，我们的一致性校验算法也需要写到这个方法里面。这个方法会执行任务片并返回下次需要执行的任务片。</p>
<p>我们使用fiber来跟踪任务片的执行。</p>
<h4 id="The-fiber-data-structure"><a href="#The-fiber-data-structure" class="headerlink" title="The fiber data structure"></a>The fiber data structure</h4><p>每个组件（__注意，这里的组件不仅是用户定义的组件，也代表浏览器原生的HTML标签__）我们都会为其创建一个fiber。<code>nextUnitOfWork</code>指向的是下一次我们要运行的fiber。<code>performUnitOfWork</code>会执行当前的fiber并在执行结束后返回一个新的fiber。跟紧我，接下来我将详细解释一下。</p>
<p>先来看下fiber的结构：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fiber = &#123;</span><br><span class="line">    <span class="attr">tag</span>: HOST_COMPONENT,</span><br><span class="line">   	<span class="attr">type</span>: <span class="string">&#x27;div&#x27;</span>,</span><br><span class="line">    <span class="attr">parent</span>: parentFiber,</span><br><span class="line">    <span class="attr">child</span>: childFiber,</span><br><span class="line">    <span class="attr">sibling</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">alternate</span>: currentFiber,</span><br><span class="line">    <span class="attr">stateNode</span>: <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>),</span><br><span class="line">    <span class="attr">props</span>: &#123;<span class="attr">children</span>: [], <span class="attr">className</span>: <span class="string">&#x27;foo&#x27;</span>&#125;,</span><br><span class="line">    <span class="attr">partialState</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">effectTag</span>: PLACEMENT,</span><br><span class="line">   	<span class="attr">effects</span>: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看起来只是一个很普通的JS对象。</p>
<p><code>parent</code>，<code>child</code>以及<code>sibling</code>将被用来构建一颗描述组件的fiber树。<code>stateNode</code>指向一个DOM元素或者是用户定义的组件的实例。</p>
<p><img src="/images/201812031109.png" alt="变量说明"></p>
<p>上面的图片展示了我们需要支持的三种类型的组件：</p>
<ul>
<li><code>b</code>，<code>p</code>及<code>i</code>这一类的fiber我们称为__host components__，用<code>tag:HOST_COMPONENT</code>来表示。这一类fiber的<code>type</code>属性值为一个字符串（即对应的html元素标签名）。<code>props</code>则放置着对应元素的属性和事件。</li>
<li><code>Foo</code>对应的fiber我们称为__class components__，对应的<code>tag</code>标签值为<code>CLASS_COMPONENT</code>。这一类fiber的<code>type</code>属性值为指向用户定义的组件类的引用。</li>
<li><code>div</code>对应的fiber我们称为__host root__。host root和host component都含有一个DOM元素作为<code>stateNode</code>的属性值，但host root作为fiber树的根，将会受到一些特别的对待。我们使用<code>tag:HOST_ROOT</code>来区分host root。注意到，此类fiber的<code>stateNode</code>对应的DOM节点将会被传入到<code>Didact.render()</code>中。</li>
</ul>
<p>另一个比较重要的属性是<code>alternate</code>。__大多数情况下我们代码中存在两棵fiber树：一颗对应着已经渲染到页面的DOM，我们称之为current tree或者old tree；另一颗为我们更新（调用<code>setState()</code>或者<code>Didact.render()</code>）过程中构建的树，我们称之为work-in-progress tree。__（这两棵树的节点都是一个个fiber）</p>
<p>work-in-progress tree不会和old tree共享fiber。一旦work-in-progress tree构建结束，对应的DOM都被渲染完毕，work-in-progress tree就会变成old tree。</p>
<p><code>alternate</code>用来连接work-in-progress tree上的fiber对应的old tree上的fiber。一个fiber与它的<code>alternate</code>指向的old tree上的fiber拥有相同的<code>tag</code>，<code>type</code>和<code>stateNode</code>。当我们在渲染一个新的结构时，对应的fiber不会含有<code>alternate</code>属性。</p>
<p>接下来是<code>effects</code>数组和<code>effectTag</code>。当work-in-progress tree上的某一个fiber需要对DOM做一些变更时，我们会给这个fiber设置<code>effecttTag</code>属性，取值有三种：<code>PLACEMENT</code>，<code>UPDATE</code>，或者<code>DELETION</code>。为了更方便的实施DOM的变更，我们将当前fiber下含有<code>effectTag</code>的子fiber都保存在<code>effects</code>数组中。</p>
<p>上面说了比较多的概念，一时理解有些困难，如果跟不上也不要担心，下面我们在实际代码中来了解一下fiber。</p>
<h4 id="Didact-call-hierarchy"><a href="#Didact-call-hierarchy" class="headerlink" title="Didact call hierarchy"></a>Didact call hierarchy</h4><p>我们通过流程图来感知一下即将要写的代码的调用层次：</p>
<p><img src="/images/201812038046.png" alt="fiber流程"></p>
<p>我们会从<code>render()</code>或者<code>setState()</code>开始，到<code>commitAllWork()</code>结束。</p>
<h4 id="Old-code"><a href="#Old-code" class="headerlink" title="Old code"></a>Old code</h4><p>在开始重写之前先来回顾下以前写的代码。</p>
<p>在<a target="_blank" rel="noopener" href="https://engineering.hexacta.com/didact-element-creation-and-jsx-d05171c55c56">Element creation and JSX</a>中我们编写了<a target="_blank" rel="noopener" href="https://gist.github.com/pomber/2bf987785b1dea8c48baff04e453b07f"><code>crerateElement()</code></a>方法用来转译JSX。这个方法不需要改动，元素的结构也没有发生变化。如果你不知道我们所说的元素，<code>type</code>，<code>props</code>和<code>children</code>是什么，那么你需要回顾一下之前的内容。</p>
<p>在<a target="_blank" rel="noopener" href="https://engineering.hexacta.com/didact-instances-reconciliation-and-virtual-dom-9316d650f1d0">Instances, reconciliation and virtual DOM</a>这一节我们写了<code>updateDomProperties()</code>方法用来更新DOM节点的属性。我们还写了<code>createDomElement()</code>方法用来创建DOM节点。这两个方法你都可以在<a target="_blank" rel="noopener" href="https://gist.github.com/pomber/c63bd22dbfa6c4af86ba2cae0a863064">dom-utils.js</a>中看到。</p>
<p>在<a target="_blank" rel="noopener" href="https://engineering.hexacta.com/didact-components-and-state-53ab4c900e37">Components and state</a>这一节我们编写了<code>Component</code>基础类。这个类需要一些改动。<code>setState()</code>方法中需要去调用<code>scheduleUpdate()</code>方法。此外还要创建一个<code>createInstance</code>方法来代替之前的<code>createPublicInstance()</code>方法，<code>createInstance</code>创建的实例保存了自身对应的fiber的引用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.props = props || &#123;&#125;;</span><br><span class="line">        <span class="built_in">this</span>.state = <span class="built_in">this</span>.state || &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">setState</span>(<span class="params">partialState</span>)</span>&#123;</span><br><span class="line">        scheduleUpdate(<span class="built_in">this</span>, partialState);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createInstance</span>(<span class="params">fiber</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> instance = <span class="keyword">new</span> fiber.type(fiber.props);</span><br><span class="line">    instance.__fiber = fiber;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们就从上面这段代码开始，重写剩下的功能。</p>
<p><img src="/images/201812032124.png" alt="render()&amp;scheduleUpdate()"></p>
<p>除了<code>Component</code>类和<code>createElement()</code>方法外，我们还有两个暴露出来的方法：<code>render()</code>和<code>setState()</code>，并且我们知道我们将在<code>setState()</code>中调用<code>scheduleUpdate()</code>。</p>
<p><code>render()</code>方法和<code>scheduleUpdate()</code>方法有些类似，它们都会接收一个更新（本文提到的更新既包括页面的初次渲染，也包括字面意义上的更新）任务，然后放到队列中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fiber分类标签</span></span><br><span class="line"><span class="keyword">const</span> HOST_COMPONENT = <span class="string">&#x27;host&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> CLASS_COMPONENT = <span class="string">&#x27;class&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> HOST_ROOT = <span class="string">&#x27;root&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量</span></span><br><span class="line"><span class="keyword">const</span> updateQueue = [];</span><br><span class="line"><span class="keyword">let</span> nextUnitOfWork = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> pendingCommit = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">elements, containerDom</span>)</span>&#123;</span><br><span class="line">    updateQueue.push(&#123;</span><br><span class="line">        <span class="attr">from</span>: HOST_ROOT,</span><br><span class="line">        <span class="attr">dom</span>: containerDom,</span><br><span class="line">        <span class="attr">newProps</span>: &#123;<span class="attr">children</span>: elements&#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    requestIdleCallback(performWork);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scheduleUpdate</span>(<span class="params">instance, partialState</span>)</span>&#123;</span><br><span class="line">    updateQueue.push(&#123;</span><br><span class="line">        <span class="attr">from</span>: CLASS_COMPONENT,</span><br><span class="line">        <span class="attr">instance</span>: instance,</span><br><span class="line">        <span class="attr">partialState</span>: partialState</span><br><span class="line">    &#125;);</span><br><span class="line">    requestIdleCallback(performWork); <span class="comment">// 延迟调用performWork</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>updateQueue</code>数组用来盛装要实施的更新，每次调用<code>render()</code>或者<code>scheduleUpdate()</code>方法都会往<code>updateQueue</code>中增加一个更新操作。每个更新操作携带的信息都不相同，我们将会在接下来的<code>resetNextUnitOfWork()</code>方法中看到如何去实施这些更新。</p>
<p>在把更新放到队列中之后，我们对<code>performWork()</code>做了一个延迟调用（意思是在浏览器空闲的时候调用）。</p>
<p><img src="/images/201812040958.png" alt="performWork()&amp;workLoop()"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ENOUGH_TIME = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">performWork</span>(<span class="params">deadline</span>)</span>&#123;</span><br><span class="line">    workLoop(deadline);</span><br><span class="line">    <span class="keyword">if</span>(nextUnitOfWork || updateQueue.length &gt; )&#123;</span><br><span class="line">        requestIdleCallback(performWork);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">workLoop</span>(<span class="params">deadline</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!nextUnitOfWork)&#123;</span><br><span class="line">        resetNextUnitOfWork(); <span class="comment">// 产生第一个nextUnitOfWork</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(nextUnitOfWork &amp;&amp; deadline.timeRemaining() &gt; ENOUGH_TIME)&#123;</span><br><span class="line">        nextUnitOfWork = performUnitOfWork(nextUnitOfWork);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pendingCommit)&#123;</span><br><span class="line">        commitAllWork(pendingCommit);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>requestIdleCallback()</code>方法会将一个deadline传入目标方法（就是<code>performWork()</code>）中，并执行这个方法。<code>performWork()</code>会将接收到的deadline传递给<code>workLoop()</code>方法，<code>workLoop()</code>执行结束后，<code>performWork()</code>中剩下的代码还会检查是否还有等待完成的任务，如果有，则会在浏览器空闲的时候再次调用自己。</p>
<p><code>workLoop()</code>会监视着deadline参数，如果deadline太短，方法内部会自动停止循环，并保持nextUnitOfWork不做改变，下次会继续执行这个任务。</p>
<blockquote>
<p> ENOUGH_TIME是一个代表1ms的常量，通过<code>deadline.timeRemaining()</code>与ENOUGH_TIME的比较来判断是否有足够的时间来执行当前这个任务。如果<code>performUnitOfWork()</code>所需要的时间超过ENOUGH_TIME，我们会适当增加deadline的值。deadline只是浏览器所建议的一个时间，所以增加几毫秒时没有什么问题的。</p>
<p> （We use <code>ENOUGH_TIME</code> (a 1ms constant, same as <a target="_blank" rel="noopener" href="https://github.com/facebook/react/blob/b52a5624e95f77166ffa520476d68231640692f9/packages/react-reconciler/src/ReactFiberScheduler.js#L154">React’s</a>) to check if <code>deadline.timeRemaining()</code> is enough to run another unit of work or not. If <code>performUnitOfWork()</code> takes more than that, we will overrun the deadline. The deadline is just a suggestion from the browser, so overrunning it for a few milliseconds is not that bad.—-这一段说实话我不太明白什么意思）</p>
</blockquote>
<p><code>performUnitOfWork()</code>会为当前的更新操作构建一颗work-in-progress tree，并会比较出需要对DOM实施的变更。这些操作都是逐步进行的，每次构建一个fiber节点。</p>
<p>当<code>performUnitOfWork()</code>结束了当前更新所需要做的任务之后，会返回null（这样循环就结束了）并将要实施的更新操作保存在<code>pendingCommit</code>变量中。最后，<code>commitAllWork()</code>会从<code>pendingCommit</code>中取出<code>effects</code>，并对对应的DOM实施变更操作。</p>
<p>注意到<code>commitAllWork()</code>是在循环外面调用的。<code>performUnitOfWork()</code>的任务完成后并没有对DOM进行变更（只是记录），所以它是可以分开执行的，而<code>commitAllWork()</code>是会对DOM进行改变的，所以为了保证代码和UI显示一致，需要一次性将<code>commitAllWork()</code>执行完毕。</p>
<p>说了这么多，我们依然不知道第一个<code>nextUnitOfWork</code>来自于哪里。</p>
<p><img src="/images/201812042140.png" alt="resetUnitOfWork()"></p>
<p><code>resetUnitOfWork()</code>方法会接收一个更新操作并将其转化为<code>nextUnitOfWork</code>（其实就是根fiber）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resetNextUnitOfWork</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> update = updateQueue.shift();</span><br><span class="line">    <span class="keyword">if</span>(!update)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将更新操作中携带的state复制给对应fiber</span></span><br><span class="line">    <span class="keyword">if</span>(update.partialState)&#123; <span class="comment">// 通过setState()更新才会有partialState</span></span><br><span class="line">        update.instance.__fiber.partialState = update.partialState;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> root = update.from == HOST_ROOT</span><br><span class="line">    	? update.dom.__rootContainerFiber</span><br><span class="line">    	: getRoot(update.instance.__fiber);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注意看，这时候的fiber都是没有child属性的，返回的是根节点的fiber。</span></span><br><span class="line">    <span class="comment">// 就是old tree的根节点</span></span><br><span class="line">    nextUnitOfWork = &#123;</span><br><span class="line">        <span class="attr">tag</span>: HOST_ROOT,</span><br><span class="line">        <span class="comment">// 如果是render()引起的话，stateNode从update.dom取值，否则从root.stateNode取值</span></span><br><span class="line">        <span class="attr">stateNode</span>: update.dom || root.stateNode,</span><br><span class="line">        <span class="comment">// props同理</span></span><br><span class="line">        <span class="attr">props</span>: update.newProps || root.props;</span><br><span class="line">        alternate: root</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRoot</span>(<span class="params">fiber</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> node = fiber;</span><br><span class="line">    <span class="keyword">while</span>(node.parent)&#123;</span><br><span class="line">        node = node.parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，<code>resetNextUnitOfWork()</code>会从<code>updateQueue</code>头部取出一个更新操作，如果这个更新操作携带有<code>partialState</code>信息，那么将该信息复制到此次更新对应组件实例的fiber上，在稍后调用组件的<code>render()</code>方法时会用到这个<code>partialState</code>。</p>
<p>接下来是寻找old fiber tree的根节点。如果此次更新是整个应用第一次调用<code>render()</code>（第一次渲染）引起的，则不存在根fiber节点，所以<code>root = null</code>；如果此次更新是由非第一次调用<code>render()</code>方法引起的，我们则可以通过DOM节点的<code>__rootContainerFiber</code>属性找到根fiber节点；如果此次更新是由<code>setState()</code>引起的，则需要从当前fiber往上查找，直到找到没有<code>parent</code>属性那个fiber节点，即为根fiber节点。</p>
<p>找完根fiber节点后，我们给<code>nextUnitOfWork</code>赋值一个新的fiber。__这个fiber是一棵新work-in-progress tree的根fiber节点__（因为是本次渲染的第一个<code>nextUnitOfWork</code>，所以是根fiber节点）。</p>
<p>如果不存在old root（说明这是初次渲染），则<code>stateNode</code>就是传入<code>render()</code>方法的那个DOM节点，<code>props</code>是来自于此次渲染的<code>newProps</code>，<code>newProps</code>的<code>children</code>数组含有的其他元素也会被传入到<code>render()</code>方法中。<code>alternate</code>属性将会是<code>null</code>（因为是初次渲染，不存在old tree）。</p>
<p>如果存在old root（真正意义上的更新操作，增量渲染），则<code>stateNode</code>就是上一次渲染的根DOM节点，<code>props</code>同样会从<code>newProps</code>取值，如果<code>newProps</code>为<code>null</code>的话，则从old root上取值。<code>alternate</code>指向的就是old root。</p>
<p>现在已经有了work-in-progress tree个根fiber节点，接下来我们从这个根节点开始构建work-in-progress fiber tree。</p>
<p><img src="/images/201812051509.png" alt="performUnitOfWork"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">performUnitOfWork</span>(<span class="params">wipFiber</span>)</span>&#123;</span><br><span class="line">    beginWork(wipFiber);</span><br><span class="line">    <span class="keyword">if</span>(wipFiber.child)&#123;</span><br><span class="line">        <span class="keyword">return</span> wipFiber.child;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果没有子元素，则寻找兄弟元素</span></span><br><span class="line">    <span class="keyword">let</span> uow = wipFiber;</span><br><span class="line">    <span class="keyword">while</span>(uow)&#123;</span><br><span class="line">        completeWork(uow); <span class="comment">// 如果wipFiber没有子元素，或者当所有子节点都被处理完毕时会被调用</span></span><br><span class="line">        <span class="keyword">if</span>(uow.sibling)&#123;</span><br><span class="line">            <span class="keyword">return</span> uow.sibling； <span class="comment">// 返回找到的兄弟元素，构建一个节点。</span></span><br><span class="line">        &#125;</span><br><span class="line">        uow = uow.parent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>performUnitOfWork()</code>方法会贯穿于整棵fiber树的构建过程。</p>
<p><code>beginWork()</code>用来为传入的fiber创建子fiber节点，然后将第一个子fiber节点返回作为下一个<code>nextUnitOfWork</code>参数。</p>
<p>如果当前已有fiber不存在子节点，则执行<code>completeWork()</code>方法，然后返回其兄弟节点作为下一个<code>nextUnitOfWork</code>参数。</p>
<p>如果当前fiber连兄弟节点也不存在，则向上查找，并逐层调用<code>completeWork</code>方法，直到找到并返回兄弟节点或者到达根节点。</p>
<p>fiber树的创建过程中，<code>performUnitOfWork()</code>会被调用多次。</p>
<p>我们会以深度优先的原则去创建一棵fiber树。从根节点开始，遍历每个节点的第一个子fiber（即child属性所指向的对象）。当到达某一个fiber节点时，我们会将该节点作为入参去调用<code>performUnitOfWork()</code>；如果某一fiber节点不含有子节点，则往右移动找寻兄弟节点，如果不存在兄弟节点则往上寻找祖先元素的兄弟节点，如此进行直到找到兄弟节点并将其带入到<code>performUnitOfWork()</code>中执行或者到达根节点。然后以当前节点为起点，继续按照深度优先的原则去遍历和创建fiber节点，整个过程会调用<code>performUnitOfWork()</code>多次，直到整棵树创建完毕。（可以在这里<a target="_blank" rel="noopener" href="https://fiber-debugger.surge.sh/">fiber-debugger</a>查看更生动的描述）</p>
<p><img src="/images/201812052125.png" alt="beginWork&amp;updateHostComponent&amp;updateClassComponent"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">beginWork</span>(<span class="params">wipFiber</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(wipFiber.tag == CLASS_COMPONENT)&#123;</span><br><span class="line">        updateClassComponent(wipFiber)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        updateHostComponent(wipFiber)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateHostComponent</span>(<span class="params">wipFiber</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!wipFiber.stateNode)&#123;</span><br><span class="line">        wipFiber.stateNode = createDomElement(wipFiber);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> newChildElements = wipFiber.props.children;</span><br><span class="line">    reconcileChildrenArray(wipFiber, newChildElements);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateClassComponent</span>(<span class="params">wipFiber</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> instance = wipFiber.stateNode;</span><br><span class="line">    <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="comment">// 调用构造函数，创建实例</span></span><br><span class="line">        instance = wipFiber.stateNode = createInstance(wipFiber)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(wipFiber.props == instance.props &amp;&amp; !wipFiber.partialState)&#123;</span><br><span class="line">        cloneChildFiber(wipFiber);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    instance.props = wipFiber.props;</span><br><span class="line">    instance.state = <span class="built_in">Object</span>.assign(&#123;&#125;, instance.state, wipFiber.partialState);</span><br><span class="line">    wipFiber.partialState = <span class="literal">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> newChildElements = wipFiber.stateNode.render();</span><br><span class="line">    reconcileChildrenArray(wipFiber, newChildElements);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>beginWork()</code>做了两件事：</p>
<ul>
<li>如果传入的fiber没有<code>stateNode</code>节点的话为其创建一个。</li>
<li>获取组件的子元素，并将它们传入<code>reconcileChildrenArray()</code>中。</li>
</ul>
<p>因为要考虑不同的组件类型，所以干脆就分成了两个方法来处理：<code>updateHostComponent()</code>和<code>updateClassComponent()</code>。</p>
<p><code>updateHostComponent()</code>方法用来处理host components及root component两种类型组件。如果传入的fiber不含有<code>stateNode</code>，则方法会为其创建一个（只有一个节点且不含有子元素，更不会添加到页面上），然后方法会从fiber的<code>props</code>属性中取出<code>children</code>并传入<code>reconcileChildrenArray()</code>中去执行性。</p>
<p>传入<code>updateClassComponent()</code>方法的fiber如果没有实例的话，则方法内部首先会通过调用组件的构建函数为其创建一个实例。创建出来的实例会被添加最新的 <code>props</code>和<code>state</code>属性，之后调用实例的<code>render()</code>方法来获取最新的子元素。如果传入进来的fiber有对应的实例，则说明不是一个新的节点。这时候如果fiber的props和实例的props相等，并且fiber上不带有<code>partialState</code>属性，则说明节点前后没有发生变化（相当于一个简易版的<code>shouldComponentUpdate()</code>），不需要重新渲染，直接克隆该节点到work-in-progress tree就可以了。</p>
<p>现在我们有了子元素<code>newChildElements</code>，可以继续向下构建work-in-progress fiber tree了。</p>
<p><img src="/images/201812062154.png" alt="reconcileChildrenArray()"></p>
<p><code>reconcileChildrenArray()</code>是一个比较核心的代码，fiber树的构建以及要对DOM实施的变化都会在这个方法里面完成。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PLACEMENT = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> DELETION = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> UPDATE = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">arrify</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> val == <span class="literal">null</span> ? <span class="literal">null</span> : <span class="built_in">Array</span>.isArray(val) ? val : [val];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reconcileChildArray</span>(<span class="params">wipFiber, newChildElements</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> elements = arrify(newChildElements);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> oldFiber = wipFiber.alternate ? wipFiber.alternate.child : <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> newFiber = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(index &lt; elements.length || oldFiber != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">const</span> prevFiber = newFiber;</span><br><span class="line">        <span class="keyword">const</span> element = index &lt; elements.length &amp;&amp; elements[index];</span><br><span class="line">        <span class="keyword">const</span> sameType = oldFiber &amp;&amp; element &amp;&amp; element.type == oldFiber.type;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(sameType)&#123; <span class="comment">// 如果前后fiber类型一样，说明是一个更新操作</span></span><br><span class="line">            newFiber = &#123;</span><br><span class="line">                <span class="attr">type</span>: oldFiber.type,</span><br><span class="line">                <span class="attr">tag</span>: oldFiber.tag,</span><br><span class="line">                <span class="attr">stateNode</span>: oldFiber.stateNode,</span><br><span class="line">                <span class="attr">props</span>: element.props,</span><br><span class="line">                <span class="attr">parent</span>: wipFiber,</span><br><span class="line">                <span class="attr">alternate</span>: oldFiber,</span><br><span class="line">                <span class="attr">partialState</span>: oldFiber.partialState,</span><br><span class="line">                <span class="attr">effectTag</span>: UPDATE</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(element &amp;&amp; !sameType)&#123;</span><br><span class="line">            newFiber = &#123;</span><br><span class="line">                <span class="attr">type</span>: element.type,</span><br><span class="line">                <span class="attr">tag</span>: </span><br><span class="line">                	<span class="keyword">typeof</span> element.type === <span class="string">&#x27;string&#x27;</span> ?HOST_COMPPONENT: CLASS_COMPONENT,</span><br><span class="line">                <span class="attr">props</span>: element.props,</span><br><span class="line">                <span class="attr">parent</span>: wipFiber,</span><br><span class="line">                <span class="attr">effectTag</span>: PLACEMENT</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(oldFiber &amp;&amp; !sameType)&#123;</span><br><span class="line">            oldFiber.effectTag = DELETION;</span><br><span class="line">            wipFiber.effects = wipFiber.effects || [];</span><br><span class="line">            wipFiber.effects.push(oldFiber); <span class="comment">// 记录oldFiber的删除操作</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(oldFiber)&#123;</span><br><span class="line">            oldFiber = oldFiber.sibling;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(index == <span class="number">0</span>)&#123;</span><br><span class="line">            wipFiber.child = newFiber; <span class="comment">// fiber的child属性指向的是第一个子fiber</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(prevFiber &amp;&amp; element)&#123;</span><br><span class="line">            prevFiber.sibling = newFiber; <span class="comment">// 剩下的子fiber相互之间通过sibling属性关联</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>一开始我们要确保传入的<code>newChildElements</code>是个数组。（这和我们之前写的一致性校验的算法有些不同，之前的<code>render()</code>方法返回的是一个对象，不支持数组，现在这个是子元素全部放在数组中，也就是说我们可以在组件的<code>render()</code>方法中直接返回一个数组了）。</p>
<p>接下来将<code>wipFiber.alernate</code>（即old fiber tree）的子节点与<code>wipFiber.props.children</code>对应的元素或者执行<code>wipFiber.stateNode.render()</code>后返回的元素进行比较。（fiber节点与元素进行比较，这地方的元素就是用对象表示的JSX）</p>
<p>在比较时，是<code>oldFiber</code>-<code>element</code>成对的比较。先是第一个fiber子节点（<code>oldFiber = wipFiber.alternate.child</code>）与第一个子元素（<code>elements[0]</code>）比较，比较结束后，<code>oldFiber</code>赋值为其自身的兄弟节点（<code>oldFiber = oldFiber.sibling</code>），然后继续与第二个子元素比较（<code>elements[1]</code>）。比较结束后再次执行<code>oldFiber = oldFiber.sibling</code>，然后再将<code>oldFiber</code>与<code>elements[2]</code>比较。以此方式比较下去：</p>
<ul>
<li>如果<code>oldFiber</code>和对应的<code>element</code>有相同的<code>type</code>，则代表<code>oldFiber.stateNode</code>可以被重用，我们会基于<code>oldFiber</code>来创建一个新的fiber，并将新fiber的<code>effectTag</code>属性设置为<code>UPDATE</code>，然后将这个新的fiber添加到work-in-progress tree上。</li>
<li>如果<code>element</code>与对应的<code>oldFiber</code>的<code>type</code>属性值不一样，或者说当前的<code>element</code>没有对应的<code>oldFiber</code>（新增元素的情况），我们会根据<code>element</code>上含有的信息新建一个fiber。注意，这个新建的fiber没有<code>alternate</code>属性，也没有<code>stateNode</code>属性（<code>stateNode</code>属性会在<code>beginWork()</code>中被创建）。我们会将这个新建fiber的<code>effectTag</code>设置为<code>PLACEMENT</code>。</li>
<li>如果<code>element</code>与对应的<code>oldFiber</code>的<code>type</code>属性值不一样，或者<code>oldFiber</code>没有对应的<code>element</code>（说明有元素需要被删除），我们会将<code>oldFiber</code>的<code>effectTag</code>设置为<code>DELETION</code>。由于<code>oldFiber</code>并不是work-in-progress tree的一部，我们需要将其添加到<code>wipFiber.effects</code>列表中以防止丢失。</li>
</ul>
<p><em>我们并没有像React那样使用key属性来做一致性校验，如果子元素只是换了一个位置的话，我们的代码并不会做特殊处理。</em></p>
<p><img src="/images/201812071640.png" alt="cloneChildFibers()"></p>
<p><code>updateClassComponent()</code>方法中考虑了一种特殊的情况，当某个节点不需要更新时，可以直接将对应old filber tree上的节点拷贝到work-in-progress tree上，省去了一致性校验的过程。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneChildFibers</span>(<span class="params">parentFiber</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> oldFiber = parentFiber.alternate; <span class="comment">// 获取传入的fiber对应的oldFiber</span></span><br><span class="line">    <span class="keyword">if</span>(!oldFiber.child)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> oldChild = oldFiber.child;</span><br><span class="line">    <span class="keyword">let</span> prevChild = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(oldChild)&#123; <span class="comment">// 循环拷贝子元素</span></span><br><span class="line">        <span class="keyword">const</span> newChild = &#123;</span><br><span class="line">            <span class="attr">type</span>: oldChild.type,</span><br><span class="line">            <span class="attr">tag</span>: oldChild.tag,</span><br><span class="line">            <span class="attr">stateNode</span>: oldChild.stateNode,</span><br><span class="line">            <span class="attr">props</span>: oldChild.props,</span><br><span class="line">            <span class="attr">partialState</span>: oldChild.partialState,</span><br><span class="line">            <span class="attr">alternate</span>: oldChild,</span><br><span class="line">            <span class="attr">parent</span>: parentFiber</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">if</span>(prevChild)&#123;</span><br><span class="line">            prevChild.sibling = newChild;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parentFiber.child = newChild;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        prevChild = newChild;</span><br><span class="line">        oldChild = oldChild.sibling; <span class="comment">//  通过sibling（兄弟）关系循环所有子元素</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>cloneChildFibers()</code>会克隆传入的<code>wipFiber.alternate</code>指向的fiber的所有子元素，并将它们添加到work-in-progress tree上。因为确定这些节点没有发生什么变化，所以并不需要添加<code>effectTag</code>属性。</p>
<p><img src="/images/201812081525.png" alt="completeWork()"></p>
<p>在<code>performUnitOfWork()</code>中，当<code>wipFiber</code>没有子元素或者当所有子元素都被执行完毕后，我们就会调用<code>completeWork()</code>方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">completeWork</span>(<span class="params">fiber</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fiber.tag == CLASS_COMPONENT)&#123; <span class="comment">// 如果是一个类组件</span></span><br><span class="line">        fiber.stateNode.__fiber = fiber;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 每次更新都要重新构建一整颗fiber树</span></span><br><span class="line">    <span class="keyword">if</span>(fiber.parent)&#123;</span><br><span class="line">        <span class="keyword">const</span> childEffects = fiber.effects || [];</span><br><span class="line">        <span class="keyword">const</span> thisEffect = fiber.effectTag != <span class="literal">null</span> ? [fiber] : [];</span><br><span class="line">        <span class="keyword">const</span> parentEffects = fiber.parent.effects || [];</span><br><span class="line">        fiber.parent.effects = parentEffects.concat(childEffects, thisEffect);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pendingCommit = fiber;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>completeWork()</code>首先更新传入的fiber对应实例类组件对象的fiber引用（可能不一定非要在这个地方，但代码里需要这么几行代码）。</p>
<p>接下来，方法内部会构建一个<code>effcts</code>列表，这个列表会将work-in-progres sub-tree上含有<code>effectTag</code>属性的fiber都包含在内（old sub-tree上含有<code>DELETION effectTag</code>的fiber也会被包含在这个effects列表中）。通过这样的<code>effects</code>列表，根fiber的<code>efffects</code>会包含所有带有<code>effectTag</code>的fiber。</p>
<p>最后，当fiber不含有<code>parent</code>属性时，说明我们已经到达了work-in-progress tree的根部，此时，我们已经完成了此次的更新操作所需要的工作，并收集了所有的effects。接下来，我们将根节点赋值给<code>pendingCommit</code>，然后<code>workLoop()</code>会去调用<code>commmitAllWork()</code>来完成更新。</p>
<p><img src="/images/201812081608.png" alt="commitAllWork&amp;commitWork"></p>
<p>接下来就剩一件事了，将更新实施到DOM上。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitAllWork</span>(<span class="params">fiber</span>)</span>&#123;</span><br><span class="line">    fiber.effects.forEach(<span class="function"><span class="params">f</span> =&gt;</span> &#123;</span><br><span class="line">        commitWork(f);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 根fiber节点对应的DOM节点有个__rootContainerFiber属性引用着根fiber</span></span><br><span class="line">    fiber.stateNode.__rootContainerFiber = fiber;</span><br><span class="line">    nextUnitOfWork = <span class="literal">null</span>;</span><br><span class="line">    pendingCommit = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitWork</span>(<span class="params">fiber</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fiber.tag == HOST_ROOT)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> domParentFiber = fiber.parent;</span><br><span class="line">    <span class="comment">// 寻找一个dom类型的祖先fiber(stateNode属性对应为原生DOM)</span></span><br><span class="line">    <span class="keyword">while</span>(domParentFiber.tag == CLASS_COMPONENT)&#123;</span><br><span class="line">        domParentFiber = domParentFiber.parent;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 有了DOM才好去调用DOM的那些方法去操作DOM</span></span><br><span class="line">    <span class="keyword">const</span> domParent = domParentFiber.stateNode;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(fiber.effectTag == PLACEMENT &amp;&amp; fiber.tag = HOST_COMPONENT)&#123; <span class="comment">// 添加一个DOM</span></span><br><span class="line">        domParent.appendChild(fiber.stateNode);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(fiber.effectTag == UPDATE)&#123; <span class="comment">// 更新一个DOM</span></span><br><span class="line">        updateDomProperties(fiber.stateNode, fiber.alternate.props, fiber.props);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(fiber.effectTag == DELETION)&#123;</span><br><span class="line">        commitDeletion(fiber, domParent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitDeletion</span>(<span class="params">fiber, domParent</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> node =fiber;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(node.tag == CLASS_COMPONENT)&#123;</span><br><span class="line">            node = node.child;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        domParent.removeChild(node.stateNode);</span><br><span class="line">        <span class="comment">// 如果node不等于fiber，并且没有兄弟节点，说明已经删除完毕</span></span><br><span class="line">        <span class="keyword">while</span>(node != fiber &amp;&amp; !node.sibling)&#123;</span><br><span class="line">            node = node.parent; <span class="comment">// 删除完毕后node重置为刚开始的值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node == fiber)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        node = node.sibling;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>commitAllWork()</code>会循环根fiber上的<code>effects</code>数组，针对每个元素都会去调用<code>commitWork()</code>方法。<code>commitWork</code>会检查每个fiber的<code>effectTag</code>属性：</p>
<ul>
<li><code>effectTag:PLACEMENT</code>：先找到父DOM节点，然后直接将fiber的<code>stateNode</code>属性对应的DOM节点直接append到父DOM节点下。</li>
<li><code>effectTag:UPDATE</code>：将<code>stateNode</code>及其对应的新旧props传入<code>updateDomProperties</code>中，方法内部再去对节点进行更新。</li>
<li><code>effectTag:DELETION</code>：如果当前的fiber是一个host component（<code>stateNode</code>属性为一个原生DOM节点），这种时候直接通过其父节点调用<code>removeChild()</code>方法来删除该节点；如果当前的fiber是一个class component，在进行删除之前，需要找到组件对应的sub fiber-tree上所有的host component，然后再进行删除。</li>
</ul>
<p>当前的effects都被实施后，需要重置<code>nextUnitOfWork</code>和<code>pendingCommit</code>，work-in-progress tree也变成了old tree，所以我们会将它的根节点设置到其对应DOM节点的<code>__rootContainerFiber</code>属性上。这些都做完后，当前的更新就都完成了，我们可以进行下一个了。</p>
<h4 id="Running-Didact"><a href="#Running-Didact" class="headerlink" title="Running Didact"></a>Running Didact</h4><p>把上面我们写的代码加入到Didact中，然后暴露公共API即可：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">importDidact</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">// All the code we wrote</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        createElement,</span><br><span class="line">        render,</span><br><span class="line">        Component</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**<span class="doctag">@jsx </span>Didact.createElement*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloMessage</span> <span class="keyword">extends</span> <span class="title">Didact</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello &#123;this.props.name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Didact.render(</span><br><span class="line">	<span class="xml"><span class="tag">&lt;<span class="name">HelloMessage</span> <span class="attr">name</span>=<span class="string">&#x27;John&#x27;</span> &gt;</span>,</span></span><br><span class="line"><span class="xml">	document.getElementById(&#x27;container&#x27;)</span></span><br><span class="line"><span class="xml">)</span></span><br></pre></td></tr></table></figure>

<h4 id="What’s-next"><a href="#What’s-next" class="headerlink" title="What’s next?"></a>What’s next?</h4><p>React的很多特性Didact都没有，其中我比较感兴趣的就是根据优先级来调度更新：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">NoWork</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">SynchronousPriority</span>:  <span class="number">1</span>, <span class="comment">// For controlled text inputs.Synchronous side-effects.</span></span><br><span class="line">    <span class="attr">TaskPriority</span>: <span class="number">2</span>,<span class="comment">// Completes at the end of the current tick</span></span><br><span class="line">    <span class="attr">HighPriority</span>: <span class="number">3</span>,<span class="comment">//Interaction that needs to complete preety soon to feel responsive</span></span><br><span class="line">    <span class="attr">LowPriority</span>: <span class="number">4</span>, <span class="comment">//Data fetching, or result from updating stores</span></span><br><span class="line">    <span class="attr">OffscreenPriority</span>: <span class="number">5</span> <span class="comment">//Won&#x27;t be  visible but do the work in case it becomes visible</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以如果有下一节的话可能就会涉及到上面的内容。</p>
<p>以上就是全部内容了。如果你喜欢，别忘了点赞，或者<a target="_blank" rel="noopener" href="https://twitter.com/pomber">推特上关注我</a>。</p>
<p>记得留下你的评论。</p>
<p>感谢阅读，喜欢的记得点击star。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2018/12/23/React%E9%87%8C%E7%9A%84%E6%B5%85%E6%AF%94%E8%BE%83/" class="prev">PREV</a><a href="/2018/10/15/column-count/" class="next">NEXT</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'seansun';
var disqus_identifier = '2018/12/12/构建自己的React-Didact-fiber/';
var disqus_title = '构建自己的React:Didact fiber';
var disqus_url = 'http://mengfansheng.com/2018/12/12/构建自己的React-Didact-fiber/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//seansun.disqus.com/count.js" async></script><div class="copyright"><p>© 2015 - 2021 <a href="http://mengfansheng.com">孟凡胜</a>, <a href="http://www.beian.miit.gov.cn" target="_blank">苏ICP备17022623号</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>