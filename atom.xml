<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Neo</title>
  
  <subtitle>He is the one</subtitle>
  <link href="http://mengfansheng.com/atom.xml" rel="self"/>
  
  <link href="http://mengfansheng.com/"/>
  <updated>2021-12-11T02:52:08.819Z</updated>
  <id>http://mengfansheng.com/</id>
  
  <author>
    <name>孟凡胜</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>代数效应</title>
    <link href="http://mengfansheng.com/2021/12/11/%E4%BB%A3%E6%95%B0%E6%95%88%E5%BA%94/"/>
    <id>http://mengfansheng.com/2021/12/11/%E4%BB%A3%E6%95%B0%E6%95%88%E5%BA%94/</id>
    <published>2021-12-11T02:47:07.000Z</published>
    <updated>2021-12-11T02:52:08.819Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/%E4%BB%A3%E6%95%B0%E6%95%88%E5%BA%94/%E4%BB%A3%E6%95%B0%E6%95%88%E5%BA%94.001.jpeg" alt="Alt text"><br><img src="/images/%E4%BB%A3%E6%95%B0%E6%95%88%E5%BA%94/%E4%BB%A3%E6%95%B0%E6%95%88%E5%BA%94.002.jpeg" alt="Alt text"><br><img src="/images/%E4%BB%A3%E6%95%B0%E6%95%88%E5%BA%94/%E4%BB%A3%E6%95%B0%E6%95%88%E5%BA%94.003.jpeg" alt="Alt text"><br><img src="/images/%E4%BB%A3%E6%95%B0%E6%95%88%E5%BA%94/%E4%BB%A3%E6%95%B0%E6%95%88%E5%BA%94.004.jpeg" alt="Alt text"><br><img src="/images/%E4%BB%A3%E6%95%B0%E6%95%88%E5%BA%94/%E4%BB%A3%E6%95%B0%E6%95%88%E5%BA%94.005.jpeg" alt="Alt text"><br><img src="/images/%E4%BB%A3%E6%95%B0%E6%95%88%E5%BA%94/%E4%BB%A3%E6%95%B0%E6%95%88%E5%BA%94.006.jpeg" alt="Alt text"><br><img src="/images/%E4%BB%A3%E6%95%B0%E6%95%88%E5%BA%94/%E4%BB%A3%E6%95%B0%E6%95%88%E5%BA%94.007.jpeg" alt="Alt text"><br><img src="/images/%E4%BB%A3%E6%95%B0%E6%95%88%E5%BA%94/%E4%BB%A3%E6%95%B0%E6%95%88%E5%BA%94.008.jpeg" alt="Alt text"><br><img src="/images/%E4%BB%A3%E6%95%B0%E6%95%88%E5%BA%94/%E4%BB%A3%E6%95%B0%E6%95%88%E5%BA%94.009.jpeg" alt="Alt text"><br><img src="/images/%E4%BB%A3%E6%95%B0%E6%95%88%E5%BA%94/%E4%BB%A3%E6%95%B0%E6%95%88%E5%BA%94.010.jpeg" alt="Alt text"><br><img src="/images/%E4%BB%A3%E6%95%B0%E6%95%88%E5%BA%94/%E4%BB%A3%E6%95%B0%E6%95%88%E5%BA%94.011.jpeg" alt="Alt text"><br><img src="/images/%E4%BB%A3%E6%95%B0%E6%95%88%E5%BA%94/%E4%BB%A3%E6%95%B0%E6%95%88%E5%BA%94.012.jpeg" alt="Alt text"><br><img src="/images/%E4%BB%A3%E6%95%B0%E6%95%88%E5%BA%94/%E4%BB%A3%E6%95%B0%E6%95%88%E5%BA%94.013.jpeg" alt="Alt text"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/%E4%BB%A3%E6%95%B0%E6%95%88%E5%BA%94/%E4%BB%A3%E6%95%B0%E6%95%88%E5%BA%94.001.jpeg&quot; alt=&quot;Alt text&quot;&gt;&lt;br&gt;&lt;img src=&quot;/image</summary>
      
    
    
    
    
    <category term="React 代数效应 fiber Algebraic Effects" scheme="http://mengfansheng.com/tags/React-%E4%BB%A3%E6%95%B0%E6%95%88%E5%BA%94-fiber-Algebraic-Effects/"/>
    
  </entry>
  
  <entry>
    <title>webpack是如何加载模块的（三）：react是如何实现路由级动态加载的</title>
    <link href="http://mengfansheng.com/2021/12/10/webpack%E6%98%AF%E5%A6%82%E4%BD%95%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9D%97%E7%9A%84%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://mengfansheng.com/2021/12/10/webpack%E6%98%AF%E5%A6%82%E4%BD%95%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9D%97%E7%9A%84%EF%BC%88%E4%B8%89%EF%BC%89/</id>
    <published>2021-12-10T13:53:37.000Z</published>
    <updated>2021-12-11T02:53:32.149Z</updated>
    
    <content type="html"><![CDATA[<p>以下内容所使用的webpack版本是4.43。</p><p>react实现动态加载官方目前给出的方案有两种，一种是使用<code>import()</code>语法，配合loadable-component这个第三方库使用；一种是使用<code>React.lazy()</code>。<code>React.lazy()</code>目前不支持服务端渲染，如果想在服务端做动态加载只能使用<code>import()</code>+loadable-component方法。</p><p>实现动态加载首先要做的就是确定哪些代码需要动态加载，也就是代码的分割界限如何设定。分割的一个标准就是要确保分割后的代码在动态加载时不能影响到用户体验。</p><p><strong>路由级动态加载</strong>就是根据路由来进行代码分割。应用中的代码是按照路由进行分割的，路由不同的页面在打包时会被打包到不同文件中，当访问某个具体路由时，当前路由对应的页面就会被动态加载进来。根据路由来进行代码分割的好处就是用户一般感知不到代码加载过程。因为用户一般习惯于在页面切换的间隙有一定的等待时间，如果在这个等待时间加载代码的话，那么代码加载对用户体验的影响会比较小。而且由于在切换页面时用户默认允许一个等待时间，在等待时也不会对元素进行操作，也就避免了一些异常情况的出现。</p><p>下面看下loadable-component实现路由级动态加载的逻辑。</p><p>通过前面两篇文章的讲解，我们知道，<code>import(chunkId)</code>语法在编译后实际变成了下面这个样子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__webpack_require_.e(chunkId).then(__webpack_require.bind(chunkPath))</span><br></pre></td></tr></table></figure><p><code>__webpack_require.e()</code>：动态加载代码</p><p><code>__webpack_require.bind(chunkPath)</code>：运行模块代码，并返回模块导出的内容</p><p>以上这些将在下面讲解的时候用到。</p><p>App.js</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> loadable <span class="keyword">from</span> <span class="string">&#x27;./loadable/component/src&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  BrowserRouter <span class="keyword">as</span> Router,</span><br><span class="line">  Route,</span><br><span class="line">  Link</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Async = loadable(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./Async&#x27;</span>), &#123;<span class="attr">fallback</span>: <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>loading...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>&#125;);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [showAsync, setShowAsync] = useState(<span class="literal">false</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Router</span>&gt;</span></span></span><br><span class="line"><span class="xml">    App</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&#x27;/async&#x27;</span>&gt;</span>Async<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;/async&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Async</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">Router</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><p>Async.js</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Async</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Async<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Async;</span><br></pre></td></tr></table></figure><p>上面组件的业务很简单：当访问<code>/async</code>路由时先去<strong>远程加载</strong><code>Async</code>组件代码然后再<strong>渲染</strong>。</p><p><code>&lt;Route /&gt;</code>路由组件的作用是当访问这个路由时再渲染对应的页面/组件，动态加载的功能并不是<code>&lt;Route /&gt;</code>实现的。对于要动态加载的组件，需要通过<code>loadable()</code>方法处理下，<code>loadable()</code>其实是一个具有动态加载内部组件功能的HOC，为了方便后面的叙述，把经过loadable处理过的组件加个HOC-前缀。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HOCAsync = loadable(</span><br><span class="line">  <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./Async&#x27;</span>), </span><br><span class="line">  &#123;<span class="attr">fallback</span>: <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>loading...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>&#125; <span class="comment">// 加载时显示的loading状态</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">/*******************/</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;/async&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">HOCAsync</span> /&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>当访问<code>/async</code>路由时，<code>HOCAsync</code>会先被渲染，其内部检测到真正的Async组件代码还没有加载的话就会先去加载，加载结束后再渲染。</p><p>接着来看下<code>loadable()</code>方法是如何实现动态加载的。</p><p>文章开头就说了，<code>import(chunkId)</code>在经过编译后变成下面的样子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__webpack_require_.e(chunkId).then(__webpack_require.bind(chunkPath))</span><br></pre></td></tr></table></figure><p>那么<code>()=&gt;import(&#39;./Async&#39;)</code>编译后的结果其实就是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">()=&gt; __webpack_require_.e(chunkId).then(__webpack_require.bind(chunkPath))</span><br></pre></td></tr></table></figure><p>说白了就是一个返回模块导出内容的函数。</p><p><code>loadable()</code>内部的实现逻辑其实也比较简单，在<code>componentDidMount()</code>中触发执行上面的代码加载逻辑：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.mounted = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.state.loading) &#123;</span><br><span class="line">    <span class="built_in">this</span>.loadAsync() <span class="comment">// 加载代码</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">this</span>.state.error) &#123;</span><br><span class="line">    <span class="built_in">this</span>.triggerOnLoad()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加载完毕就能获取到组件内容，然后渲染：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">loadAsync</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">this</span>.promise) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; __chunkExtractor, forwardedRef, ...props &#125; = <span class="built_in">this</span>.props</span><br><span class="line">    <span class="comment">// ctor.requireAsync就是() =&gt; import(&#x27;./Async.js&#x27;)方法</span></span><br><span class="line">    <span class="built_in">this</span>.promise = ctor</span><br><span class="line">      .requireAsync(props) <span class="comment">// 这地方为什么要传props:为了支持full dynamic imports</span></span><br><span class="line">      .then(<span class="function"><span class="params">loadedModule</span> =&gt;</span> &#123; <span class="comment">// loadedModule就是模块导出的内容</span></span><br><span class="line">      <span class="keyword">const</span> result = resolve(loadedModule, &#123; Loadable &#125;) <span class="comment">// 加载到的组件存储在result变量中</span></span><br><span class="line">      <span class="keyword">if</span> (options.suspense) &#123;</span><br><span class="line">        <span class="built_in">this</span>.setCache(result)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">    &#125;)</span><br><span class="line">      .catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.safeSetState(&#123; error, <span class="attr">loading</span>: <span class="literal">false</span> &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.promise</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>loadAsync()</code>方法将获取到的模块内容放到<code>result</code>变量中，接下来在<code>render()</code>方法中渲染<code>result</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="comment">// 在未成功加载前，先渲染传入进来的loading组件</span></span><br><span class="line">  <span class="keyword">const</span> fallback = propFallback || options.fallback || <span class="literal">null</span></span><br><span class="line">  <span class="keyword">if</span> (loading) &#123;</span><br><span class="line">    <span class="keyword">return</span> fallback</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> render(&#123;</span><br><span class="line">    loading,</span><br><span class="line">    fallback,</span><br><span class="line">    result,</span><br><span class="line">    options,</span><br><span class="line">    <span class="attr">props</span>: &#123; ...props, <span class="attr">ref</span>: forwardedRef &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>loadable()</code>方法对组件做了一定的性能优化。在使用时，可以传入cacheKey，用来作为组件是否发生改变的标志，如果没有传入cacheKey，则默认使用<code>JSON.stringfy(props)</code>的返回值作为cacheKey，每次外层HOC更新完毕后会比较前后两次cacheKey是否发生改变，如有改变，则重新调用<code>this.loadAsync()</code>方法计算最新的组件内容然后再渲染：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCacheKey</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (options.cacheKey) &#123;</span><br><span class="line">    <span class="keyword">return</span> options.cacheKey(props) <span class="comment">// 计算缓存key</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (ctor.resolve) &#123;</span><br><span class="line">    <span class="keyword">return</span> ctor.resolve(props)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">  <span class="built_in">super</span>(props)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.state = &#123;</span><br><span class="line">    <span class="attr">result</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">error</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">loading</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">cacheKey</span>: getCacheKey(props), <span class="comment">// 设置缓存key：cacheKey</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ....</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">componentDidUpdate</span>(<span class="params">prevProps, prevState</span>)</span> &#123;</span><br><span class="line">  <span class="comment">// 如果cacheKey有变化，则重新获取组件内容然后重新渲染</span></span><br><span class="line">  <span class="keyword">if</span> (prevState.cacheKey !== <span class="built_in">this</span>.state.cacheKey) &#123;</span><br><span class="line">    <span class="built_in">this</span>.promise = <span class="literal">null</span></span><br><span class="line">    <span class="built_in">this</span>.loadAsync()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：loadable是一个HOC，内部依然是使用的webpack的<code>__webpack_require_.e(chunkId)</code>方法动态加载的代码。在工作时，外层组件会先去远程加载组件内容，然后再渲染。可以设置cacheKey属性，增强组件性能。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;以下内容所使用的webpack版本是4.43。&lt;/p&gt;
&lt;p&gt;react实现动态加载官方目前给出的方案有两种，一种是使用&lt;code&gt;import()&lt;/code&gt;语法，配合loadable-component这个第三方库使用；一种是使用&lt;code&gt;React.lazy()&lt;</summary>
      
    
    
    
    
    <category term="react" scheme="http://mengfansheng.com/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>webpack是如何加载模块的（二）：异步模块的加载</title>
    <link href="http://mengfansheng.com/2021/12/10/webpack%E6%98%AF%E5%A6%82%E4%BD%95%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9D%97%E7%9A%84%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://mengfansheng.com/2021/12/10/webpack%E6%98%AF%E5%A6%82%E4%BD%95%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9D%97%E7%9A%84%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2021-12-10T13:52:34.000Z</published>
    <updated>2021-12-11T02:53:01.224Z</updated>
    
    <content type="html"><![CDATA[<p>以下内容所使用的webpack版本是4.43。</p><p>webpack可以把项目代码打包成一个bundle.js，如果项目比较大的话，这个bundle.js体积也会比较大。如果用户打开首页上来就加载一个很大的文件的话，一定程度上会影响用户的体验。而且，这个bundle.js还包含了一些用户不常访问的页面，这不经常访问的页面没有必要打包进去（因为访问几率比较低），可以在访问时再去加载这个页面的代码。这样减少了初次加载的bundle.js的体积，可以提高初次访问时页面打开的速度。但是这种方式也增加了http请求次数，因为要去按需加载，同时还要加载一些控制按需加载的代码。所以，在使用webpack按需加载进行项目优化时，需要综合考虑。</p><p>有两种按需加载的实现方式，一种是使用正在处于ECMAScript提议阶段的import()语法；另一种是使用webpack自己的规范require.ensure。</p><blockquote><p>import()内部使用promise实现。因此在老的浏览器中使用的话要注意兼容。</p></blockquote><p>本文接下来研究的是通过<code>import()</code>方法加载异步模块的实现。</p><p>同样是两个文件：</p><p>index.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setInterval</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">window</span>.show)&#123;</span><br><span class="line">    <span class="keyword">import</span>(<span class="string">&#x27;./asyncc.js&#x27;</span>).then(<span class="function">(<span class="params">&#123;<span class="keyword">default</span>: text&#125;</span>) =&gt;</span> <span class="built_in">console</span>.log(text))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure><p>async.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> text=<span class="string">&#x27;async&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> text;</span><br></pre></td></tr></table></figure><p>打包后获得两个文件，先忽略细节，看结构</p><p>index.bundle.js：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">modules</span>) </span>&#123; </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">webpackJsonpCallback</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 模块缓存</span></span><br><span class="line">  <span class="keyword">var</span> installedModules = &#123;&#125;;</span><br><span class="line">  <span class="comment">// 已加载（0）/待加载（undefined）/预加载（preloaded）/正在加载（promise）的模块</span></span><br><span class="line">  <span class="keyword">var</span> installedChunks = &#123;</span><br><span class="line">    <span class="string">&quot;index&quot;</span>: <span class="number">0</span></span><br><span class="line">  &#125;;</span><br><span class="line">   </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">jsonpScriptSrc</span>(<span class="params">chunkId</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="comment">// The require function</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">__webpack_require__</span>(<span class="params">moduleId</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  __webpack_require__.e = <span class="function"><span class="keyword">function</span> <span class="title">requireEnsure</span>(<span class="params">chunkId</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"> &#125;;</span><br><span class="line">  <span class="keyword">return</span> __webpack_require__(__webpack_require__.s = <span class="string">&quot;./src/index.js&quot;</span>);</span><br><span class="line"> &#125;)(&#123;</span><br><span class="line"> <span class="string">&quot;./src/index.js&quot;</span>:</span><br><span class="line">   (<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">module</span>, __webpack_exports__, __webpack_require__</span>) </span>&#123;</span><br><span class="line"><span class="meta">    &quot;use strict&quot;</span>;</span><br><span class="line">    __webpack_require__.r(__webpack_exports__);</span><br><span class="line">    <span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">window</span>.show) &#123;</span><br><span class="line">        __webpack_require__.e(<span class="comment">/*! import() */</span> <span class="number">0</span>).</span><br><span class="line">        then(__webpack_require__.bind(<span class="literal">null</span>, <span class="string">&quot;./src/asyncc.js&quot;</span>)).</span><br><span class="line">        then(<span class="function"><span class="keyword">function</span> (<span class="params">_ref</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">var</span> text = _ref[<span class="string">&quot;default&quot;</span>];</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">console</span>.log(text);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">    __webpack_exports__[<span class="string">&quot;default&quot;</span>] = (<span class="string">&#x27;ssss&#x27;</span>);</span><br><span class="line">   &#125;)</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure><p>0.bundle.js：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="built_in">window</span>[<span class="string">&quot;webpackJsonp&quot;</span>] = <span class="built_in">window</span>[<span class="string">&quot;webpackJsonp&quot;</span>] || []).push([[<span class="number">0</span>],&#123;</span><br><span class="line"><span class="string">&quot;./src/asyncc.js&quot;</span>:</span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">module</span>, __webpack_exports__, __webpack_require__</span>) </span>&#123;</span><br><span class="line"><span class="meta">    &quot;use strict&quot;</span>;</span><br><span class="line">    __webpack_require__.r(__webpack_exports__);</span><br><span class="line">    <span class="keyword">var</span> text = <span class="string">&#x27;async&#x27;</span>;</span><br><span class="line">    __webpack_exports__[<span class="string">&quot;default&quot;</span>] = (text);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;]);</span><br></pre></td></tr></table></figure><p>从整体看打包后文件结构和都是同步加载时的打包文件结构差不多：都是一个立即执行函数，函数入参同样也是一个以文件路径为key，文件内容为值的对象（姑且称之为<strong>模块对象</strong>）；同样使用了<code>__webpack_require__(moduleId)</code>加载同步代码；同样有模块缓存<code>installedModules</code>。</p><p>也有一些不同点，比如，相比都是同步加载，使用异步加载的代码打包后文件内容要多一些，有一些方法在同步加载时没有（比如webpackJsonpCallback，jsonpScriptSrc）；需要同步加载的所有文件都打包在了一块，但需要异步加载的文件单独打包了出来（0.bundle.js）；对模块的加载状态进行了记录<code>installedChunks</code>。</p><p>对于同步文件的加载依然是使用<code>__webpack_require__(moduleId)</code>来加载，具体解析可以看上一篇文章。下面看下index.js中是如何加载async.js的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;./src/index.js&quot;</span>:(<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">module</span>, __webpack_exports__, __webpack_require__</span>) </span>&#123;</span><br><span class="line"><span class="meta">    &quot;use strict&quot;</span>;</span><br><span class="line">    __webpack_require__.r(__webpack_exports__);</span><br><span class="line">    <span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">window</span>.show) &#123;</span><br><span class="line">        __webpack_require__.e(<span class="comment">/*! import() */</span> <span class="number">0</span>).</span><br><span class="line">        then(__webpack_require__.bind(<span class="literal">null</span>, <span class="string">&quot;./src/asyncc.js&quot;</span>)).</span><br><span class="line">        then(<span class="function"><span class="keyword">function</span> (<span class="params">_ref</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">var</span> text = _ref[<span class="string">&quot;default&quot;</span>];</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">console</span>.log(text);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">    __webpack_exports__[<span class="string">&quot;default&quot;</span>] = (<span class="string">&#x27;ssss&#x27;</span>);</span><br><span class="line">   &#125;)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>以上是index.js编译后得到的内容。对照源码可以看到原来的<code>import(&#39;./async&#39;)</code>被编译成了<code>__webpack__require__.e(0)</code>，<code>__webpack__require__.e</code>方法源码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">__webpack_require__.e = <span class="function"><span class="keyword">function</span> <span class="title">requireEnsure</span>(<span class="params">chunkId</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> promises = [];</span><br><span class="line">  <span class="keyword">var</span> installedChunkData = installedChunks[chunkId];</span><br><span class="line">  <span class="keyword">if</span>(installedChunkData !== <span class="number">0</span>) &#123; <span class="comment">// 0 表示已经加载过</span></span><br><span class="line">    <span class="comment">// 正在加载</span></span><br><span class="line">    <span class="keyword">if</span>(installedChunkData) &#123;</span><br><span class="line">      promises.push(installedChunkData[<span class="number">2</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 创建promise，并存放到缓存installedChunks中</span></span><br><span class="line">      <span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        installedChunkData = installedChunks[chunkId] = [resolve, reject];</span><br><span class="line">      &#125;);</span><br><span class="line">      promises.push(installedChunkData[<span class="number">2</span>] = promise);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 开始加载异步模块</span></span><br><span class="line">      <span class="comment">// 创建script标签</span></span><br><span class="line">      <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">      <span class="keyword">var</span> onScriptComplete;</span><br><span class="line">      <span class="comment">// 设置字符集</span></span><br><span class="line">      script.charset = <span class="string">&#x27;utf-8&#x27;</span>;</span><br><span class="line">      <span class="comment">// 设置超时时间</span></span><br><span class="line">      script.timeout = <span class="number">120</span>;</span><br><span class="line">      <span class="keyword">if</span> (__webpack_require__.nc) &#123;</span><br><span class="line">        script.setAttribute(<span class="string">&quot;nonce&quot;</span>, __webpack_require__.nc);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 设置src</span></span><br><span class="line">      script.src = jsonpScriptSrc(chunkId);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> error = <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">      <span class="comment">// 加载完成/超时/出错 事件响应方法</span></span><br><span class="line">      onScriptComplete = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 避免IE中出现内存泄漏</span></span><br><span class="line">        script.onerror = script.onload = <span class="literal">null</span>; </span><br><span class="line">        <span class="comment">// 清除定时器</span></span><br><span class="line">        <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">        <span class="keyword">var</span> chunk = installedChunks[chunkId];</span><br><span class="line">          <span class="keyword">if</span>(chunk !== <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(chunk) &#123;</span><br><span class="line">              <span class="comment">// 设置错误信息</span></span><br><span class="line">              <span class="keyword">var</span> errorType = event &amp;&amp; (event.type === <span class="string">&#x27;load&#x27;</span> ? <span class="string">&#x27;missing&#x27;</span> : event.type);</span><br><span class="line">              <span class="keyword">var</span> realSrc = event &amp;&amp; event.target &amp;&amp; event.target.src;</span><br><span class="line">              error.message = <span class="string">&#x27;Loading chunk &#x27;</span> + chunkId + <span class="string">&#x27; failed.\n(&#x27;</span> + errorType + <span class="string">&#x27;: &#x27;</span> + realSrc + <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">              error.name = <span class="string">&#x27;ChunkLoadError&#x27;</span>;</span><br><span class="line">              error.type = errorType;</span><br><span class="line">              error.request = realSrc;</span><br><span class="line">              chunk[<span class="number">1</span>](error);</span><br><span class="line">            &#125;</span><br><span class="line">            installedChunks[chunkId] = <span class="literal">undefined</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 定时器，超时后触发</span></span><br><span class="line">        <span class="keyword">var</span> timeout = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">          onScriptComplete(&#123; <span class="attr">type</span>: <span class="string">&#x27;timeout&#x27;</span>, <span class="attr">target</span>: script &#125;);</span><br><span class="line">        &#125;, <span class="number">120000</span>);</span><br><span class="line">        script.onerror = script.onload = onScriptComplete;</span><br><span class="line">        <span class="comment">// 将script标签添加到head内，开始加载脚本</span></span><br><span class="line">        <span class="built_in">document</span>.head.appendChild(script);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.all(promises);</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>上面一段代码看着东西挺多，但其实做的事情挺简单：</p><ol><li><p>检查要加载的代码是否已经加载过，加载过则直接返回，否则继续往下走；</p></li><li><p>创建一个代表即将要加载的代码的promise，并将这个promise存储到内存中供后面使用；</p></li><li><p>接着就是创建script标签，设置script的一些包括src在内的属性，然后将scirpt标签append到head内，浏览器就会自动根据src去加载代码</p></li></ol><p>在设置加载路径也就是script的src属性时，用到了<code>jsonpScriptSrc(chunkId)</code>这个方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonpScriptSrc</span>(<span class="params">chunkId</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> __webpack_require__.p + <span class="string">&quot;&quot;</span> + (&#123;&#125;[chunkId]||chunkId) + <span class="string">&quot;.bundlle.js&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法很简单，就是根据传进来的chunkId生成对应的chunk路径，这里的<code>__webpack__require__.p</code>就是webpack配置中的<code>publicPath</code>。我们这个例子中没有设置<code>publicPath</code>，所以<code>src</code>值为<code>0.bundle.js</code>。</p><p>所加载的0.bundle.js内容如下，也就是async.js打包后的内容：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="built_in">window</span>[<span class="string">&quot;webpackJsonp&quot;</span>] = <span class="built_in">window</span>[<span class="string">&quot;webpackJsonp&quot;</span>] || []).push([[<span class="number">0</span>],&#123;</span><br><span class="line"><span class="string">&quot;./src/asyncc.js&quot;</span>:(<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">module</span>, __webpack_exports__, __webpack_require__</span>) </span>&#123;</span><br><span class="line"><span class="meta">    &quot;use strict&quot;</span>;</span><br><span class="line">    __webpack_require__.r(__webpack_exports__);</span><br><span class="line">    <span class="keyword">var</span> text = <span class="string">&#x27;async&#x27;</span>;</span><br><span class="line">    __webpack_exports__[<span class="string">&quot;default&quot;</span>] = (text);</span><br><span class="line"></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;]);</span><br></pre></td></tr></table></figure><p>这段代码中先是用到了<code>window.webpackJsonp.push</code>方法，这个方法在主打包文件index.bundle.js中可以找到定义：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jsonpArray = <span class="built_in">window</span>[<span class="string">&quot;webpackJsonp&quot;</span>] = <span class="built_in">window</span>[<span class="string">&quot;webpackJsonp&quot;</span>] || [];</span><br><span class="line"><span class="keyword">var</span> oldJsonpFunction = jsonpArray.push.bind(jsonpArray);</span><br><span class="line">jsonpArray.push = webpackJsonpCallback;</span><br></pre></td></tr></table></figure><p>所以<code>window.webpackJsonp.push</code>其实就是<code>webpackJsonpCallback()</code>方法，方法内容如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">webpackJsonpCallback</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> chunkIds = data[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">var</span> moreModules = data[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> moduleId, chunkId, i = <span class="number">0</span>, resolves = [];</span><br><span class="line">  <span class="keyword">for</span>(;i &lt; chunkIds.length; i++) &#123;</span><br><span class="line">    chunkId = chunkIds[i];</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Object</span>.prototype.hasOwnProperty.call(installedChunks, chunkId) &amp;&amp; installedChunks[chunkId]) &#123;</span><br><span class="line">      <span class="comment">// 收集各模块的resolve方法，供后面统一处理</span></span><br><span class="line">      resolves.push(installedChunks[chunkId][<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    installedChunks[chunkId] = <span class="number">0</span>; <span class="comment">// 加载完成后，对应模块在installedChunks中的值为0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将加载的模块添加到modules对象上</span></span><br><span class="line">  <span class="keyword">for</span>(moduleId <span class="keyword">in</span> moreModules) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Object</span>.prototype.hasOwnProperty.call(moreModules, moduleId)) &#123;</span><br><span class="line">      modules[moduleId] = moreModules[moduleId]; <span class="comment">// 将异步加载到的模块放到modules中</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(parentJsonpFunction) parentJsonpFunction(data);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(resolves.length) &#123;</span><br><span class="line">    resolves.shift()(); <span class="comment">// 执行resolve，结束promise</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结合0.bundle.js代码，<code>webpackJsonCallback()</code>主要作用有三个：</p><ol><li>将异步加载到的模块对象放到<code>modules</code>变量中</li></ol><p>modules是外层函数的入参，这个不要忘了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(moduleId <span class="keyword">in</span> moreModules) &#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">Object</span>.prototype.hasOwnProperty.call(moreModules, moduleId)) &#123;</span><br><span class="line">    modules[moduleId] = moreModules[moduleId]; <span class="comment">// 将异步加载到的模块放到modules中</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>将已经加载的模块标记为已加载</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">installedChunks[chunkId] = <span class="number">0</span>; <span class="comment">// 加载完成后，对应模块在installedChunks中的值为0</span></span><br></pre></td></tr></table></figure><ol start="3"><li>将异步模块对应的promise结束掉</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">resolves.push(installedChunks[chunkId][<span class="number">0</span>]);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">while</span>(resolves.length) &#123;</span><br><span class="line">  resolves.shift()(); <span class="comment">// 执行resolve，结束promise</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以注意到，在结束promise时，并没有把模块内容resolve出去，所以这个模块内容是如何被引入的（每个模块都是一个方法，方法要被执行模块内容才能被引入）？</p><p>上面提到，<code>webpackJsonCallback()</code>这个方法会将模块对象加入到<code>modules</code>对象中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(moduleId <span class="keyword">in</span> moreModules) &#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">Object</span>.prototype.hasOwnProperty.call(moreModules, moduleId)) &#123;</span><br><span class="line">    modules[moduleId] = moreModules[moduleId]; <span class="comment">// 将异步加载到的模块放到modules中</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然放进去了，那肯定有用到的地方。</p><p>回到index.bundle.js中，拖到代码最下面加载async.js部分：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.show) &#123;</span><br><span class="line">  __webpack_require__.e(<span class="comment">/*! import() */</span> <span class="number">0</span>).</span><br><span class="line">   then(__webpack_require__.bind(<span class="literal">null</span>, <span class="string">&quot;./src/async.js&quot;</span>)).</span><br><span class="line">   then(<span class="function"><span class="keyword">function</span> (<span class="params">_ref</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> text = _ref[<span class="string">&quot;default&quot;</span>];</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">console</span>.log(text);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>可以看到，在异步文件加载结束后（就是promise结束后）接着调用的是<code>__webpack__require__(&#39;./src/async.js&#39;)</code>方法，入参是<code>&#39;./src/async.js&#39;</code>，接下里的事情就很明显了：<code>__webpack__require__()</code>方法根据moduleId—-<code>./src/async.js</code>去modules中加载模块，运行模块内容，接着返回模块要导出的内容。因为这里<code>__webpack__require__</code>方法是作为<code>then()</code>方法的第一个参数运行的，所以其返回内容可以被紧跟后面的<code>.then()</code>方法捕捉到，在后面的<code>.then()</code>方法中执行的就是源码中需要在async.js加载完成才能运行的代码了。</p><p><img src="../img/%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD.jpeg"></p><p>至此，整个异步代码加载完毕。</p><p><img src="../img/%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B.jpg" alt="异步加载流程"></p><p>一句话总结下就是：所谓的动态加载js，其实是通过script标签来实现的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;以下内容所使用的webpack版本是4.43。&lt;/p&gt;
&lt;p&gt;webpack可以把项目代码打包成一个bundle.js，如果项目比较大的话，这个bundle.js体积也会比较大。如果用户打开首页上来就加载一个很大的文件的话，一定程度上会影响用户的体验。而且，这个bundle</summary>
      
    
    
    
    
    <category term="webpack" scheme="http://mengfansheng.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>webpack是如何加载模块的（一）：同步模块的加载</title>
    <link href="http://mengfansheng.com/2021/12/10/webpack%E6%98%AF%E5%A6%82%E4%BD%95%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9D%97%E7%9A%84%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://mengfansheng.com/2021/12/10/webpack%E6%98%AF%E5%A6%82%E4%BD%95%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9D%97%E7%9A%84%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2021-12-10T13:49:57.000Z</published>
    <updated>2021-12-11T02:52:35.219Z</updated>
    
    <content type="html"><![CDATA[<p>以下内容所使用的webpack版本是4.43。</p><p>先看下同步加载代码。</p><p>入口文件index.js:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> text <span class="keyword">from</span> <span class="string">&#x27;./sync.js&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(text)</span><br></pre></td></tr></table></figure><p>被导入文件sync.js：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> text = <span class="string">&#x27;sync&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> text;</span><br></pre></td></tr></table></figure><p>打包后获得如下的文件：index.bundle.js（先忽略细节，看下整体结构）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">modules</span>) </span>&#123; <span class="comment">// webpackBootstrap</span></span><br><span class="line">  <span class="comment">// The module cache</span></span><br><span class="line">  <span class="keyword">var</span> installedModules = &#123;&#125;;</span><br><span class="line">  <span class="comment">// The require function</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">__webpack_require__</span>(<span class="params">moduleId</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">module</span>.exports;</span><br><span class="line">  &#125;</span><br><span class="line">     <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> __webpack_require__(__webpack_require__.s = <span class="string">&quot;./src/index.js&quot;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">  (&#123;</span><br><span class="line">    <span class="string">&quot;./src/index.js&quot;</span>:</span><br><span class="line">      (<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">module</span>, __webpack_exports__, __webpack_require__</span>) </span>&#123;</span><br><span class="line"><span class="meta">        &quot;use strict&quot;</span>;</span><br><span class="line">        __webpack_require__.r(__webpack_exports__);</span><br><span class="line">        <span class="keyword">var</span> _syncc_js__WEBPACK_IMPORTED_MODULE_0__ = </span><br><span class="line">            __webpack_require__(<span class="comment">/*! ./syncc.js */</span> <span class="string">&quot;./src/syncc.js&quot;</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(_syncc_js__WEBPACK_IMPORTED_MODULE_0__[<span class="string">&quot;default&quot;</span>]);</span><br><span class="line">      &#125;),</span><br><span class="line">    <span class="string">&quot;./src/sync.js&quot;</span>:</span><br><span class="line">      (<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">module</span>, __webpack_exports__, __webpack_require__</span>) </span>&#123;</span><br><span class="line"><span class="meta">        &quot;use strict&quot;</span>;</span><br><span class="line">        __webpack_require__.r(__webpack_exports__);</span><br><span class="line">        <span class="keyword">var</span> text = <span class="string">&#x27;sync&#x27;</span>;</span><br><span class="line">        __webpack_exports__[<span class="string">&quot;default&quot;</span>] = (text);</span><br><span class="line"></span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>可以看出，打包出的源码就是一个立即执行函数，前半部分是方法主体，后半部分是方法入参。入参是一个对象，对象的key是被打包文件的路径，而value值为一个方法，方法内运行的是模块内容。姑且把整个对象叫做模块对象。</p><p>在前半部分的函数体结尾，执行了<code>__webpack_require__(__webpack_require__.s = &quot;./src/index.js&quot;);</code>方法，整个程序其实也是从这里开始。</p><p><code>__webpack__require(moduleId)</code>：根据传入的moduleId加载对应的模块并缓存，最后返回模块导出的内容</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模块缓存</span></span><br><span class="line"><span class="keyword">var</span> installedModules = &#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__webpack_require__</span>(<span class="params">moduleId</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 检测要加载的文件是否已经缓存，若缓存过了直接返回文件导出值</span></span><br><span class="line">  <span class="keyword">if</span> (installedModules[moduleId]) &#123;</span><br><span class="line">    <span class="keyword">return</span> installedModules[moduleId].exports;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 没有加载过，创建module对象，并将这个对象放到缓存中</span></span><br><span class="line">  <span class="keyword">var</span> <span class="built_in">module</span> = installedModules[moduleId] = &#123;</span><br><span class="line">    <span class="attr">i</span>: moduleId,</span><br><span class="line">    <span class="attr">l</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">exports</span>: &#123;&#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行当前moduleId对应的函数，执行模块内代码</span></span><br><span class="line">  modules[moduleId].call(<span class="built_in">module</span>.exports, <span class="built_in">module</span>, <span class="built_in">module</span>.exports, __webpack_require__);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把当前模块标识为已加载</span></span><br><span class="line">  <span class="built_in">module</span>.l = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回模块</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">module</span>.exports;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的方法中比较重要的是下面这一句：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">modules[moduleId].call(<span class="built_in">module</span>.exports, <span class="built_in">module</span>, <span class="built_in">module</span>.exports, __webpack_require__);</span><br></pre></td></tr></table></figure><p>读取<code>moduleId</code>对应的模块加载方法并执行。</p><p><code>modules</code>就是传入进来的模块对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;./src/index.js&quot;</span>: (<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">module</span>, __webpack_exports__, __webpack_require__</span>) </span>&#123;</span><br><span class="line"><span class="meta">    &quot;use strict&quot;</span>;</span><br><span class="line">    __webpack_require__.r(__webpack_exports__);</span><br><span class="line">    <span class="keyword">var</span> _syncc_js__WEBPACK_IMPORTED_MODULE_0__ = </span><br><span class="line">        __webpack_require__(<span class="comment">/*! ./syncc.js */</span> <span class="string">&quot;./src/syncc.js&quot;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(_syncc_js__WEBPACK_IMPORTED_MODULE_0__[<span class="string">&quot;default&quot;</span>]);</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="string">&quot;./src/sync.js&quot;</span>: (<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">module</span>, __webpack_exports__, __webpack_require__</span>) </span>&#123;</span><br><span class="line"><span class="meta">      &quot;use strict&quot;</span>;</span><br><span class="line">      __webpack_require__.r(__webpack_exports__);</span><br><span class="line">      <span class="keyword">var</span> text = <span class="string">&#x27;sync&#x27;</span>;</span><br><span class="line">      __webpack_exports__[<span class="string">&quot;default&quot;</span>] = (text);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>所以，<code>modules[&#39;./src/index.js&#39;].call(...)</code>其实就是执行的下面这个函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">module</span>, __webpack_exports__, __webpack_require__</span>) </span>&#123;</span><br><span class="line"><span class="meta">  &quot;use strict&quot;</span>;</span><br><span class="line">  __webpack_require__.r(__webpack_exports__);</span><br><span class="line">  <span class="keyword">var</span> _syncc_js__WEBPACK_IMPORTED_MODULE_0__ = </span><br><span class="line">      __webpack_require__(<span class="comment">/*! ./sync.js */</span> <span class="string">&quot;./src/sync.js&quot;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(_syncc_js__WEBPACK_IMPORTED_MODULE_0__[<span class="string">&quot;default&quot;</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面方法中先是执行了<code>__webpack_require__.r</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给文件导出对象定义_esModule属性并复制为true，</span></span><br><span class="line"><span class="comment">// 同时通过修改Symbol.toStringTag属性</span></span><br><span class="line"><span class="comment">// 将export对象的toString()方法返回值设置为[object Module]</span></span><br><span class="line">__webpack_require__.r = <span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">exports</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Symbol</span> !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; <span class="built_in">Symbol</span>.toStringTag) &#123;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(<span class="built_in">exports</span>, <span class="built_in">Symbol</span>.toStringTag, &#123; <span class="attr">value</span>: <span class="string">&#x27;Module&#x27;</span> &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(<span class="built_in">exports</span>, <span class="string">&#x27;__esModule&#x27;</span>, &#123; <span class="attr">value</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接下来就是index.js源代码文件中的内容了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _syncc_js__WEBPACK_IMPORTED_MODULE_0__ = </span><br><span class="line">      __webpack_require__(<span class="comment">/*! ./syncc.js */</span> <span class="string">&quot;./src/sync.js&quot;</span>);</span><br><span class="line"> <span class="built_in">console</span>.log(_syncc_js__WEBPACK_IMPORTED_MODULE_0__[<span class="string">&quot;default&quot;</span>]);</span><br></pre></td></tr></table></figure><p>先是导入<code>sync.js</code>中的内容，然后打印输出所导入内容，和<code>index.js</code>源码内容一致：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> text <span class="keyword">from</span> <span class="string">&#x27;./syncc.js&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(text)</span><br></pre></td></tr></table></figure><p>在导入<code>sync.js</code>时，依然是使用<code>__webpack_require__()</code>方法，入参是<code>./src/sync.js</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加载sync.js</span></span><br><span class="line">__webpack_require__(<span class="string">&quot;./src/sync.js&quot;</span>);</span><br></pre></td></tr></table></figure><p>同样的，加载<code>sync.js</code>时也是先去缓存中看一下之前有没有加载过这个模块，没有的话再去加载：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">modules[moduleId].call(<span class="built_in">module</span>.exports, <span class="built_in">module</span>, <span class="built_in">module</span>.exports, __webpack_require__);</span><br></pre></td></tr></table></figure><p>执行对应的模块加载方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">module</span>, __webpack_exports__, __webpack_require__</span>) </span>&#123;</span><br><span class="line"><span class="meta">  &quot;use strict&quot;</span>;</span><br><span class="line">  __webpack_require__.r(__webpack_exports__);</span><br><span class="line">  <span class="keyword">var</span> text = <span class="string">&#x27;sync&#x27;</span>;</span><br><span class="line">  __webpack_exports__[<span class="string">&quot;default&quot;</span>] = (text);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到模块导出的内容挂在<code>__webpack_exports__</code>对象下面：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__webpack__exports__[<span class="string">&quot;default&quot;</span>] = (text);</span><br></pre></td></tr></table></figure><p>对于每个没有加载过的模块，在加载之前都会创建一个<code>module</code>对象:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有加载过，创建module对象，并将这个对象放到缓存中</span></span><br><span class="line">  <span class="keyword">var</span> <span class="built_in">module</span> = installedModules[moduleId] = &#123;</span><br><span class="line">    <span class="attr">i</span>: moduleId,</span><br><span class="line">    <span class="attr">l</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">exports</span>: &#123;&#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>而模块加载方法内的<code>__webpack__exports__</code>就是传入进来的<code>module.exports</code>对象，在<code>__webapck__require__()</code>方法最后返回<code>module.exports</code>，所以要导出的内容就被返回了。</p><p>总结一下，每个模块在编译之后都是一个函数，这些函数挂在模块对象下，以自己的文件路径为属性key，类似下面的结构：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&#x27;./src/index.js&#x27;</span>: (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="comment">// 加载其他模块</span></span><br><span class="line">    &#125;),</span><br><span class="line">    ..</span><br><span class="line">    [moduleId]: (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="comment">//..</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模块的加载过程主要用到的就是<code>__webpack_require__(moduleId)</code>这个方法。加载流程就是先加载入口模块（index.js），如果当前模块内部又引用了其他模块（sync.js），则继续使用<code>__webpack_require__(moduleId)</code>去加载，这样一直<strong>递归</strong>加载下去，直到所有模块都加载完毕。对于每个加载过的模块都会被缓存起来（存储在<code>installedModules[moduleId]</code>下），后续再次用到时会直接去缓存中获取而不用再去执行一次模块。</p><p><img src="../img/%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B.jpg"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;以下内容所使用的webpack版本是4.43。&lt;/p&gt;
&lt;p&gt;先看下同步加载代码。&lt;/p&gt;
&lt;p&gt;入口文件index.js:&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pr</summary>
      
    
    
    
    
    <category term="webpack 同步加载" scheme="http://mengfansheng.com/tags/webpack-%E5%90%8C%E6%AD%A5%E5%8A%A0%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>前端工程化</title>
    <link href="http://mengfansheng.com/2020/01/01/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    <id>http://mengfansheng.com/2020/01/01/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/</id>
    <published>2020-01-01T08:33:44.000Z</published>
    <updated>2020-03-29T03:47:42.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前端工程化"><a href="#前端工程化" class="headerlink" title="前端工程化"></a>前端工程化</h2><p>开局一张图。。。</p><p><img src="/images/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96.jpg" alt="前端工程化"></p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>将软件工程的方法和原理运用在前端开发中，目的是实现__高效开发，有效协同，质量可控__。</p><p>前端工程化目的：<strong>提升业务效率</strong></p><p>狭义的讲，前端工程化是指将开发阶段的代码转变成生产环境的代码的一系列步骤。主要包括__构建，分支管理，自动化测试，部署__等。</p><p>广义的讲，我理解还应该包括开发阶段，其中又包括开发框架搭建，基础工具（请求库、路由库等）选型，视图基础组件库选择等基础工具的选择，这些都确定了之后，剩下的就是编写业务代码。总体来讲，前端开发框架的搭建以及业务代码的编写也是工程化的一部分，也就是说，广义上的前端工程化包括了从开发框架搭建、到业务开发、到测试，再到线上部署的整个链路过程。</p><h3 id="为什么？"><a href="#为什么？" class="headerlink" title="为什么？"></a>为什么？</h3><p>为什么要把前端<strong>工程“化”</strong>？以前没有工程“化”么？工程“化”意味着什么？</p><p>早期的前端页面由JSP、PHP等在服务端生成，浏览器只负责展现，这个时候前端开发重度依赖开发环境，前后端职责纠缠不清（甚至没有前端概念），可维护性差。</p><p>Ajax出现后，前端进入SPA（Single Page Application）时代，前后端开始分离，前端职责越来越清晰。</p><p>随着前端页面复杂性增加（功能、特效、数据等），前端出现了各种框架或者说工具库来满足快速构建前端应用需求，例如Backbone、AngularJS、React、Vue等，此时进入前端为主的MVC、MV*时代。</p><p>随着应用复杂性提高，应用对前端的要求也随之提高：开发、构建、渲染、维护性、扩展性等各方面都对前端提出了很高的要求。而随着Node.js兴起，各种用nodejs编写的前端工具如雨后春笋冒出来，前端面临的很多问题也都有了解决方案。</p><p>React、Vue等工具聚焦于解决视图快速构建的问题，webpack聚焦于解决前端应用打包构建的问题，前端框架是包含前端开发各个链路在内的一整套前端开发解决方案，<strong>前端工程</strong>说的是从开发到部署线上再到后期迭代这一整个过程，而<strong>前端工程化</strong>说的则是从工程的角度管理前端开发，形成前端开发流程的一整套开发规范，提高前端开发效率。</p><p>所以，为什么前端要工程化？<strong>为了提高前端开发效率，提高前端应用的可扩展性、可维护性等性能。</strong></p><h3 id="前端工程化的内容"><a href="#前端工程化的内容" class="headerlink" title="前端工程化的内容"></a>前端工程化的内容</h3><ul><li><p>规范：代码规范、目录结构规范、前后端接口规范、文档规范、commit规范、流程规范等</p></li><li><p>分支管理：不同的开发人员开发不同的功能或组件，按照统一的流程合并到主干</p></li><li><p>组件化开发：这个是最基本的吧</p></li><li><p>模块管理：一方面，团队引用的模块应该是规范；另一方面，必须保证这些模块可以正确的加入到最终编译好的包文件中</p></li><li><p>前端技术或框架规范：</p><ul><li>CSS方案：CSS Modules，CSS in JS</li><li>视图方案：react、Vue</li><li>数据管理方案：redux、mobx</li><li>路由：react-router</li><li>请求库：fetch、axios、SWR、umi-request</li><li>…</li></ul></li><li><p>自动化测试：为了保证和并进主干的代码达到质量标准，必须有测试，而且测试应该是自动化的，可以回归的。</p></li><li><p>构建：主干更新后，自动将代码编译为最终的目标格式，并且准备好各种静态资源</p><ul><li>webpack</li><li>Babel</li></ul></li><li><p>部署：将构建好的代码部署到生产环境</p></li><li><p>版本管理，发布方式（纯前端发布）</p></li><li><p>…</p></li></ul><p>一个人开发时，使用一些工具来提升自己的效率——工程化最初阶段（工具化）</p><p>多人协同开发时，大家需要约定一些规范，所有人都需要遵守规范——规范化</p><p>当协同规模再大一点时（几十人），规范的落地变得有难度，通过一个流程的方式来保障———流程化</p><p>当协同人员数量到几百甚至上千的时候，就会形成一个一个小技术圈子，开始出现能力的重复建设和内耗，这个时候就需要对日常研发过程中的所需能力进行分层，抽象出来的基础能力通过某个平台来承载，其他业务或团队基于抽象出来的能力进行二次开发——中台化</p><p>总的来讲，<strong>一个完整的前端工程体系应该包括</strong>：</p><p>1.统一的开发规范</p><p>2.组件化开发</p><p>3.构建流程</p><p>开发规范和组件化开发面向开发阶段，宗旨是提高团队协作能力，提高开发效率并降低维护成本</p><p>构建工具和平台解决了web产品一些列的工程问题，旨在提高web产品的性能表现，提高开发效率。</p><p>参考：</p><p><a href="https://www.cnblogs.com/ihardcoder/p/5378290.html">前端工程化</a></p><p><a href="https://www.infoq.cn/article/Kpd_C06scWePcO8fB7ex">从淘宝前端工程化演进，看工程化之路如何“私人订制”</a></p><p><a href="https://juejin.im/post/58ac334e8d6d810058c103e0">我对前端工程化的理解</a></p><p><a href="https://juejin.im/post/5ac9c6f451882555677ed301">前端工程化概述</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前端工程化&quot;&gt;&lt;a href=&quot;#前端工程化&quot; class=&quot;headerlink&quot; title=&quot;前端工程化&quot;&gt;&lt;/a&gt;前端工程化&lt;/h2&gt;&lt;p&gt;开局一张图。。。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/%E5%89%8D%E7%AB%AF%E5%B7</summary>
      
    
    
    
    
    <category term="前端工程化前端 react webpack babel" scheme="http://mengfansheng.com/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E5%89%8D%E7%AB%AF-react-webpack-babel/"/>
    
  </entry>
  
  <entry>
    <title>别再问React Hooks能否代替Redux了</title>
    <link href="http://mengfansheng.com/2019/09/02/%E5%88%AB%E5%86%8D%E9%97%AEReact-Hooks%E8%83%BD%E5%90%A6%E4%BB%A3%E6%9B%BFRedux%E4%BA%86/"/>
    <id>http://mengfansheng.com/2019/09/02/%E5%88%AB%E5%86%8D%E9%97%AEReact-Hooks%E8%83%BD%E5%90%A6%E4%BB%A3%E6%9B%BFRedux%E4%BA%86/</id>
    <published>2019-09-02T15:26:58.000Z</published>
    <updated>2020-03-29T03:47:42.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>原文地址：<a href="https://medium.com/swlh/stop-asking-if-react-hooks-replace-redux-448c54d79551">https://medium.com/swlh/stop-asking-if-react-hooks-replace-redux-448c54d79551</a></p></blockquote><p>一些同事经常变着法的问我同一个问题：</p><p>“如果项目中已经在使用hooks了，那还有必要引入Redux么？”</p><p>“React Hooks的出现是不是意味Redux可以废弃？我是不是可以用hooks来做Redux可以做的事情了？”</p><p>经过一番搜索，我发现网上有好多人在问这一类问题。</p><p>简单的说，这个问题的答案是：NO！</p><p>如果再回答的细致并且礼貌一点就是：这取决于你的项目。</p><p>事实上，我更倾向于这样的回答：我不太确定你是否知道自己在问啥。</p><p>这个问题从根本上讲是有缺陷的，原因有以下几个：</p><h5 id="Redux从始至终都是一个可选项"><a href="#Redux从始至终都是一个可选项" class="headerlink" title="Redux从始至终都是一个可选项"></a>Redux从始至终都是一个可选项</h5><p>根据 Dan Abramov（Redux的作者之一）的文章，<a href="https://medium.com/@dan_abramov/you-might-not-need-redux-be46360cf367">你或许不需要Redux</a>，我们可以得出一个结论：如果我们根本不需要某个东西，那我们也就不需要替换这样东西。</p><p>如果需要在React中使用Redux，你需要引入React-Redux代码库。众所周知，代码库的引入会增加应用打包后的体积，而打包后代码的大小又直接影响着应用的加载时间。所以，除非项目真的需要，否则没有必要去引入像jQuery、Redux、MobX甚至React这些代码库。</p><p>当有人问hooks是否会替代Redux时，往往让人觉得他们的项目需要用这两者中的一个。但事实不是这样。如果你现在开发的应用并没有很多的状态需要存储，又或者你的组件层次比较简单，不存在深层次的props传递，那么就没必要去使用一个全局状态管理库。直接使用React现有的功能就足以管理好应用内的状态，用不用hooks都可以。</p><p>如果你应用内的状态或者组件层次如古树树根一般复杂，你也可以不用状态管理库。这种情况下props的传递或许会有一些复杂，但React已经提供了包含hooks在内的工具以确保你的状态能管理的井井有条。Redux虽然轻量，但配置复杂，打包后还会增加应用体积，这中间存在着一些权衡。不在项目中使用Redux的理由很多，总而言之，你要记住，Redux是一个可选项。</p><p>反过来说，使用Redux的原因也有很多。如果你的项目中一开始就用了Redux，那肯定是有原因的，比如项目需要一个可预测的，单一的数据源来使应用代码在复杂状态中保持条理，或者中间件，或者Redux开发者工具。如果你之前有理由使用Redux，那么现在React hooks并不会使这些理由失效。因此，如果你之前需要Redux，那你现在有可能依然需要redux。</p><h5 id="React-hooks和Redux所解决的并不是同一个问题"><a href="#React-hooks和Redux所解决的并不是同一个问题" class="headerlink" title="React hooks和Redux所解决的并不是同一个问题"></a>React hooks和Redux所解决的并不是同一个问题</h5><p>Redux是一个状态管理库。Hooks则是最近发布的React所提供的一项新功能，它允许在函数式组件使用一些之前只能在类组件中使用的功能。</p><p>使用函数组件替换类组件会让状态管理库过时么？不！</p><p>根据官方文档，React hooks的诞生主要为了解决以下三个痛点：</p><ul><li>在类组件之间复用逻辑困难</li><li>生命周期方法中常包含一些让人困惑的无关联的逻辑</li><li>类组件对人和机器都有一些理解上的困难</li></ul><p>可以看到，这三个原因没有一个和状态管理有关。</p><p>但是话又说回来，React hooks确实给了我们几个管理应用状态的选项。比如<code>useState</code>，<code>useReducer</code>和<code>useContext</code>几个方法所提供的管理状态的功能比原来React带有的管理状态的方法更好，更有条理。</p><p>Hooks并不是什么魔法，不会让状态管理库过时。</p><h5 id="Hooks不会让你的app具有之前版本React所不具有的功能"><a href="#Hooks不会让你的app具有之前版本React所不具有的功能" class="headerlink" title="Hooks不会让你的app具有之前版本React所不具有的功能"></a>Hooks不会让你的app具有之前版本React所不具有的功能</h5><p>有了hooks之后，你可以在函数组件中使用之前只能在类组件中的功能，但这并不会让函数组件具有类组件没有的功能，换句话说，它并没有增加组件的新功能，只是提供了一种更有条理管理代码和复用代码的方式。Hooks不会让你应用更好，只会让开发者体验更好。</p><p><code>useState</code>和<code>useReducer</code>是管理组件状态的两种方式，它们的功能和类组件中的<code>this.state</code>以及<code>this.setState</code>一样。但对于深层次的props传递问题，这些方法依然起不到大的效果。</p><p><code>useContext</code>是一个大家认为可以将Redux打入冷宫的一个方法，因为它可以解决深层次props传递的问题，但这个方法并不是什么新的功能。<a href="https://reactjs.org/docs/context.html">Context API</a>已经存在好久了，<code>useContext</code>只是让大家在使用context时不再需要<code>&lt;Consumer&gt;</code>来包裹组件。虽然一些开发者喜欢用context来保存一些全局变量，但context并不是为此而设计的。根据文档：</p><blockquote><p>Context被设计用来保存对组件树而言需要全局共享的数据，比如当前用户，主题，又或者语言。</p></blockquote><p>换句话说，保存在context中的数据不应该频繁的更新。</p><p>文档中还建议少用context，因为“它让代码难以复用”。虽然可以用context来管理状态，但那毕竟不是context被设计出来的初衷。</p><p>总结一下，React hooks的出现并不会引起Redux的灭亡。如果你看一眼<a href="https://react-redux.js.org/next/api/hooks">React-Redux最近更新的文档</a>，你会发现：</p><h5 id="React-Redux已经有了自己的hooks"><a href="#React-Redux已经有了自己的hooks" class="headerlink" title="React-Redux已经有了自己的hooks"></a>React-Redux已经有了自己的hooks</h5><p>React hooks的引入使得React-Redux代码更加健壮，也移除了一些痛点。这与“替代React-Redux”相去甚远。</p><p>我在另一篇文章中<a href="https://medium.com/swlh/clean-up-redux-code-with-react-redux-hooks-71587cfcf87a">深入研究了React-Redux中的hooks</a>，以下是这篇文章中的重点。在hooks出现之前，你需要定义<code>mapStateToProps</code>和<code>mapDispatchToProps</code>方法，并将你的组件使用<code>connect</code>包裹，产生的高阶组件会将<code>dispatch</code>方法以及store中数据通过你上面提供的两个方法处理后作为props，传入到你的组件中。</p><p>来看一个简单的计数器的例子（虽然简单到不需要引入Redux，但为了说明问题，还是引入一下）。假设我们已经定义了store，以及<code>increment</code>和<code>decrement</code>两个actions creator：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;connect&#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> actions <span class="keyword">from</span> <span class="string">&#x27;../actions/actions&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;count, increment, decrement&#125; = <span class="built_in">this</span>.props;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>The count is &#123;count&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> increment(count)&#125;&gt;+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> decrement(count)&#125;&gt;-<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mapStateToProps = <span class="function"><span class="params">store</span> =&gt;</span> (&#123;</span><br><span class="line">  <span class="attr">count</span>: store.count</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mapDispatchToProps = <span class="function"><span class="params">dispatch</span> =&gt;</span> (&#123;</span><br><span class="line">  <span class="attr">increment</span>: <span class="function"><span class="params">count</span> =&gt;</span> dispatch(actions.increment(count)),</span><br><span class="line">  <span class="attr">decrement</span>: <span class="function"><span class="params">count</span> =&gt;</span> dispatch(actions.decrement(count))</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(mapStateToProps, mapDispatchToProps)(App);</span><br></pre></td></tr></table></figure><p>相当繁琐。假如可以不用把我们的组件包括在高阶组件中就能使用redux store，这样不是更简便么？—–这就是redux中hooks的目的。Hooks解决了代码复用问题，同时减少了高阶组件包裹导致“包裹地狱”的可能。下面是同样的组件，但使用了React-Redux hooks功能：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> actions <span class="keyword">from</span> <span class="string">&#x27;../actions/actions&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;useSelector, useDispatch&#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> dispatch = useDispatch();</span><br><span class="line">  <span class="keyword">const</span> count = useSelector(<span class="function"><span class="params">store</span> =&gt;</span> store.count);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>The count is &#123;count&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> dispatch(actions.increment(count))&#125;&gt;+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> dispatch(actions.decrement(count))&#125;&gt;-<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure><p>是不是很简洁？简而言之，<code>useSelector</code>允许你将redux store中的一些数据作为变量保存在你的组件中。<code>useDispatch</code>也很简单，它提供了<code>dispatch</code>方法，你可以用来发起数据更新操作到Redux store。总而言之，你不用再写那些丑陋的映射函数或者把你的组件包裹在<code>connect</code>方法内了。现在，你的组件包含了一切该有的功能，而且代码比以前更加简短，可读性更高，更有条理。</p><h5 id="没有必要将React-hooks和Redux放在对立面"><a href="#没有必要将React-hooks和Redux放在对立面" class="headerlink" title="没有必要将React hooks和Redux放在对立面"></a>没有必要将React hooks和Redux放在对立面</h5><p>经过上面的讲解，能看出这两种技术能很好的相互成全。React hooks不会取代Redux，它只是提供了一个新的，也许能更好的组织你的代码的方式。如果你决定使用Redux，hooks或许能帮你写出更高内聚的组件。</p><p>所以，不要再问“React hooks会不会取代Redux”了？</p><p>相反，我们应该问问自己“我们在写的应用需要那种方式来管理状态？Redux在我这个项目上是否合适，是否大材小用了？是否该用hooks，还是我应该坚持使用类组件？如果我使用Redux和React hooks（或者MobX和React hooks，或者仅仅是jQuery和Redux—–这取决于你的项目），我该如何让这些技术相互补充，和谐工作呢？”</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;原文地址：&lt;a href=&quot;https://medium.com/swlh/stop-asking-if-react-hooks-replace-redux-448c54d79551&quot;&gt;https://medium.com/swlh/stop-as</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>写一个redux-saga-4：effect和effectRunner</title>
    <link href="http://mengfansheng.com/2019/07/25/%E5%86%99%E4%B8%80%E4%B8%AAredux-saga-4_effect%E5%92%8CeffectRunner/"/>
    <id>http://mengfansheng.com/2019/07/25/%E5%86%99%E4%B8%80%E4%B8%AAredux-saga-4_effect%E5%92%8CeffectRunner/</id>
    <published>2019-07-25T02:07:06.000Z</published>
    <updated>2020-03-29T03:47:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>effect表示一个副作用，effectRunner用来执行effect。</p><p>effect一般结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  payload: &#123;</span><br><span class="line">    fn,</span><br><span class="line">    context,</span><br><span class="line">    channel,</span><br><span class="line">    //...</span><br><span class="line">  &#125;,</span><br><span class="line">  type: effectType</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>payload</code>中装载着需要传给effectRunner，用来执行effect的一些数据。</p><p>代码会根据<code>type</code>属性找到对应的effectRunner，接收<code>payload</code>，然后执行。</p><p>以<code>take()</code>和<code>runTakeEffect()</code>为例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tak(action) 暂停iterator，等待指定action</span></span><br><span class="line"><span class="comment">// take(channel) 暂停iterator，等待指定channel中所包含的action</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">take</span>(<span class="params">patternOrChannel = <span class="string">&#x27;*&#x27;</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (is.pattern(patternOrChannel)) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">payload</span>: &#123; <span class="attr">pattern</span>: patternOrChannel &#125;, <span class="attr">type</span>: TAKE &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (is.channel(patternOrChannel)) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">payload</span>: &#123; <span class="attr">channel</span>: patternOrChannel &#125;, <span class="attr">type</span>: TAKE &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runTakeEffect</span>(<span class="params">env, &#123; channel = env.channel, pattern &#125;, cb, &#123;parentTask&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    channel.take(cb, matcher(pattern), TAKE);</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e)&#123;</span><br><span class="line">    cb(e, <span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>感觉没啥要写的，saga基本的功能目前已经具备(call, fork, take, put, select, cancel, join, all, race)。总结下代码吧：</p><p><a href="https://github.com/xusanduo08/easy-saga/tree/master/%E5%86%99%E4%B8%80%E4%B8%AAredux-saga-4">https://github.com/xusanduo08/easy-saga/tree/master/%E5%86%99%E4%B8%80%E4%B8%AAredux-saga-4</a></p><p>控制台可直接<code>npm run test</code>运行测试用例，以上提到的功能的测试用例均能跑通。</p><p>代码里还有个小demo，<code>npm start    ``后可以直接运行</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;effect表示一个副作用，effectRunner用来执行effect。&lt;/p&gt;
&lt;p&gt;effect一般结构如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;sp</summary>
      
    
    
    
    
    <category term="redux-saga saga redux react" scheme="http://mengfansheng.com/tags/redux-saga-saga-redux-react/"/>
    
  </entry>
  
  <entry>
    <title>写一个redux-saga-3：task</title>
    <link href="http://mengfansheng.com/2019/07/25/%E5%86%99%E4%B8%80%E4%B8%AAredux-saga-3_task/"/>
    <id>http://mengfansheng.com/2019/07/25/%E5%86%99%E4%B8%80%E4%B8%AAredux-saga-3_task/</id>
    <published>2019-07-25T01:59:01.000Z</published>
    <updated>2020-03-29T03:47:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>这一节来写一下task。</p><p>proc在运行一开始就会创建task，task是当前主任务mainTask以及分支任务的集合。task承担着当前任务的终止、取消、完成以及管理子任务等角色。</p><p>task的树形结构：</p><p><img src="/images/task%E7%BB%93%E6%9E%84.png" alt="task的结构"></p><p>关于task，有以下几个特点：</p><ul><li>task是可取消的（调用task.cancel()方法）</li><li>父任务取消时会带着未完成的子任务一起取消</li><li>当task运行出错时，task会aborted，其父任务也会aborted，兄弟任务则会被取消</li><li>一个task在结束之前，会等待其下所有分叉任务结束</li><li>来自子任务的错误会冒泡到父任务中</li><li>task运行结束后，其运行结果会通过task自身携带的promise的resolve方法传递出去</li></ul><p>要实现的功能：</p><ul><li>task可取消。取消一个task，会取消以这个task会根的task树</li><li>task结束后，会自动将结果传递到父任务回调中，父任务继续执行</li><li>当前task出错，其下所有子task都会被取消，父任务会aborted，兄弟任务会被取消，并且错误会一直冒泡到最上面的任务</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>def 延迟对象，包装了一个promise</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>mainTask 当前任务对应的主任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>name saga方法名</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>cont task完成时，需要执行的回调。如果该任务是个fork task，那么其cont方法会被父task重写</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">newTask</span>(<span class="params">def, name, mainTask, cont</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> queue = forkQueue(mainTask, end);</span><br><span class="line">  <span class="keyword">let</span> status = taskStatus.RUNNING;</span><br><span class="line">  <span class="keyword">let</span> taskResult;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">end</span>(<span class="params">res, isErr</span>)</span>&#123; <span class="comment">// 任务出错，取消，完成都会调用end，来将信息上传到上一层任务对象（通过task.cont方法）</span></span><br><span class="line">    <span class="keyword">if</span>(!isErr)&#123;</span><br><span class="line">      <span class="keyword">if</span>(res === <span class="string">&#x27;cancel_task&#x27;</span>)&#123;</span><br><span class="line">        status = taskStatus.CANCELLED</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(status !== taskStatus.CANCELLED)&#123;</span><br><span class="line">        status = taskStatus.DONE</span><br><span class="line">      &#125;</span><br><span class="line">      taskResult = res;</span><br><span class="line">      def.resolve(res);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      status = taskStatus.ABORTED;</span><br><span class="line">      def.reject(res);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    task.joiners.forEach(<span class="function"><span class="params">joiner</span> =&gt;</span> &#123; <span class="comment">// 执行等待该任务的回调</span></span><br><span class="line">      joiner.cb(res)</span><br><span class="line">    &#125;)</span><br><span class="line">    task.joiners = <span class="literal">null</span>;</span><br><span class="line">    task.cont(res, isErr);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 当一个任务被取消时，已这个任务为根的task树上的任务都会被取消，任务的joiner也会被取消</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">cancel</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(status === taskStatus.RUNNING)&#123;</span><br><span class="line">      <span class="comment">// 调用取消方法后，任务中的effec会进入到finally区块中执行（如果有的话）</span></span><br><span class="line">      status = taskStatus.CANCELLED;</span><br><span class="line">      queue.cancelAll();</span><br><span class="line">      end(<span class="string">&#x27;cancel_task&#x27;</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> task = &#123;</span><br><span class="line">    name,</span><br><span class="line">    cont,</span><br><span class="line">    status,</span><br><span class="line">    <span class="attr">isRunning</span>: <span class="function">() =&gt;</span> status === taskStatus.RUNNING,</span><br><span class="line">    <span class="attr">isCancelled</span>: <span class="function">() =&gt;</span> status === taskStatus.CANCELLED || (status === taskStatus.RUNNING &amp;&amp; mainTask.status === taskStatus.CANCELLED),</span><br><span class="line">    <span class="attr">isAborted</span>: <span class="function">() =&gt;</span> status === taskStatus.ABORTED,</span><br><span class="line">    <span class="attr">result</span>: <span class="function">() =&gt;</span> taskResult,</span><br><span class="line">    cancel,</span><br><span class="line">    queue,</span><br><span class="line">    end,</span><br><span class="line">    <span class="attr">joiners</span>: [],</span><br><span class="line">    <span class="attr">toPromise</span>: <span class="function">() =&gt;</span> def.promise</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> task</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生成一个任务队列，在添加任务时自动给任务赋值cont方法</span></span><br><span class="line"><span class="comment"> * 任务结束或者出错时会调用自身的cont方法通知父任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>mainTask 主任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> </span>end task结束方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">forkQueue</span>(<span class="params">mainTask, end</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> queue = [];</span><br><span class="line">  <span class="keyword">let</span> result;</span><br><span class="line">  <span class="keyword">let</span> completed = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  addTask(mainTask);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">addTask</span>(<span class="params">task</span>)</span>&#123;</span><br><span class="line">    queue.push(task);</span><br><span class="line">    task.cont = <span class="function">(<span class="params">res, isErr</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(completed)&#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      remove(queue, task) <span class="comment">// 该任务已执行过，将该任务从任务队列中移除</span></span><br><span class="line">      <span class="keyword">if</span>(isErr)&#123;</span><br><span class="line">        cancelAll(); <span class="comment">// 任务出错，取消队列中的其他任务</span></span><br><span class="line">        end(res, isErr); <span class="comment">// 错误信息冒泡</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(task === mainTask)&#123;</span><br><span class="line">          result = res</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!queue.length)&#123; <span class="comment">// 任务队列为空时，才会触发task的end方法</span></span><br><span class="line">          completed = <span class="literal">true</span>;</span><br><span class="line">          end(result, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">cancelAll</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(completed)&#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    completed = <span class="literal">true</span>;</span><br><span class="line">    queue.forEach(<span class="function"><span class="params">task</span> =&gt;</span> &#123;</span><br><span class="line">      task.cont = noop;</span><br><span class="line">      task.cancel();</span><br><span class="line">    &#125;)</span><br><span class="line">    queue = []</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    addTask,</span><br><span class="line">    cancelAll</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本节代码地址：<a href="https://github.com/xusanduo08/easy-saga/tree/master/%E5%86%99%E4%B8%80%E4%B8%AAredux-saga-3">https://github.com/xusanduo08/easy-saga/tree/master/%E5%86%99%E4%B8%80%E4%B8%AAredux-saga-3</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这一节来写一下task。&lt;/p&gt;
&lt;p&gt;proc在运行一开始就会创建task，task是当前主任务mainTask以及分支任务的集合。task承担着当前任务的终止、取消、完成以及管理子任务等角色。&lt;/p&gt;
&lt;p&gt;task的树形结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/im</summary>
      
    
    
    
    
    <category term="redux-saga saga reudx react" scheme="http://mengfansheng.com/tags/redux-saga-saga-reudx-react/"/>
    
  </entry>
  
  <entry>
    <title>写一个redux-saga-2：proc</title>
    <link href="http://mengfansheng.com/2019/07/25/%E5%86%99%E4%B8%80%E4%B8%AAredux-saga-2_proc/"/>
    <id>http://mengfansheng.com/2019/07/25/%E5%86%99%E4%B8%80%E4%B8%AAredux-saga-2_proc/</id>
    <published>2019-07-25T01:53:56.000Z</published>
    <updated>2020-03-29T03:47:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>这节来写proc。proc主要功能是执行iterator。我们将一个generator的运行用一个task对象来表示。proc运行返回值即为task，代表当前的saga任务。taks内部有个taskQueue队列，管理着当前主任务mainTask以及子任务（fork任务，后面会讲到）。每个saga运行后都会维护一个task树。</p><p>mainTask具有一个cont方法，mainTask结束或者运行出错时会执行cont方法，来将结束消息或者错误消息传递给task。</p><p>saga代码调用结构：</p><p><img src="/images/saga%E4%BB%A3%E7%A0%81%E8%B0%83%E7%94%A8%E7%BB%93%E6%9E%84.png"></p><p>iterator需要手动的去调用<code>iterator.next()</code>方法才会往下执行。同时，<code>iterator.next()</code>是可以传入参数的，传入的参数会被当作是上一个yield表达式的结果。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span></span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result =  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> it = gen();</span><br><span class="line">it.next(); <span class="comment">// &#123;value: 3, done: false&#125;</span></span><br><span class="line">it.next(<span class="number">4</span>); <span class="comment">// 4 &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure><p>为了满足iterator的运行，采用递归来消耗iterator。proc有个<code>next()</code>方法，该方法会被不断调用以来消耗iterator。</p><p>在generator中，<code>yield</code>语句后面可以跟普通方法、Promise、或者另一个generator方法。yield后面跟着的其实就是我们期望执行的副作用effect，每种effect都会有个对应的effectRunner来执行。</p><p>如果<code>yield</code>后面跟的依然是一个generator，那么需要运行这个generator并将返回的iterator传入proc，另起一个任务来执行这个generator。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="keyword">yield</span> subGen(); <span class="comment">// 需要另起一个proc来执行subGen()返回的iterator</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">subGen</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>runner去执行对应effect之后，需要将执行结果返回，并继续执行主程序，所以effectRunner中需要传入一个cb（callback），来告诉effectRunner副作用执行完毕后该干啥。</p><p>effect和task 是可取消的，每个effectRunner需要给传入的cb设置一个cancel方法，告诉主任务如何取消当前的effect；每个task也都需要设置一个cancel方法，以便能够被取消。对于附属task，附属task需要将自己的取消方法设置给自己的主回调（mainCb）上。</p><p>需要注意一点，已完成的effect不能再取消，已取消的effect也不能再继续下去。在<code>digestEffect()</code>中我们会保证这个互斥关系。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> effectRunner <span class="keyword">from</span> <span class="string">&#x27;./effectRunner.js&#x27;</span>；</span><br><span class="line"><span class="keyword">import</span> deferred <span class="keyword">from</span>  <span class="string">&#x27;./utils/deferred&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;is&#125; <span class="keyword">from</span> <span class="string">&#x27;./utils/is&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> newTask <span class="keyword">from</span><span class="string">&#x27;./task&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> noop <span class="keyword">from</span> <span class="string">&#x27;./utils/noop&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> taskStatus <span class="keyword">from</span> <span class="string">&#x27;./utils/taskStatus&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  iterator: 迭代器</span></span><br><span class="line"><span class="comment">  mainCb：当前任务完成后的回调</span></span><br><span class="line"><span class="comment">  name: generator的名字</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">proc</span>(<span class="params">env, iterator, mainCb, name</span>)</span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> mainTask = &#123;<span class="attr">status</span>: taskStatus.RUNNING, name&#125;;</span><br><span class="line">  <span class="keyword">let</span> def = &#123;&#125;;</span><br><span class="line">  <span class="comment">// 为什么不直接用deferred()?我也想不明白。。。。。</span></span><br><span class="line">  <span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123; </span><br><span class="line">    def.resolve = resolve;</span><br><span class="line">    def.reject = reject;</span><br><span class="line">  &#125;).catch(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(e))</span><br><span class="line">  def.promise = promise;</span><br><span class="line">  <span class="keyword">let</span> task = newTask(def, name, mainTask, mainCb);</span><br><span class="line">  mainTask.cancel = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(mainTask.status === taskStatus.RUNNING)&#123;</span><br><span class="line">      mainTask.status = taskStatus.CANCELLED;</span><br><span class="line">      next(<span class="string">&#x27;cancel_task&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 如果当前task是个附属task，则需要给mainCb设置cancel方法，便于父task的取消动作</span></span><br><span class="line">  mainCb.cancel = task.cancel;</span><br><span class="line">  next();</span><br><span class="line">  <span class="keyword">return</span> task</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">arg, isErr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      <span class="keyword">let</span> result;</span><br><span class="line">      <span class="keyword">if</span>(isErr)&#123;</span><br><span class="line">        result = iterator.throw(arg);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(arg === <span class="string">&#x27;cancel_task&#x27;</span>)&#123;</span><br><span class="line">        next.cancel(); <span class="comment">// 任务在取消时同时要取消当前还在运行着的effect</span></span><br><span class="line">        result = is.func(iterator.return) ? </span><br><span class="line">        iterator.return(<span class="string">&#x27;cancel_task&#x27;</span>): &#123;<span class="attr">value</span>:<span class="string">&#x27;cancel_task&#x27;</span>done: <span class="literal">true</span>&#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result = iterator.next(arg);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(!result.done)&#123;</span><br><span class="line">        digest(result.value, next)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mainTask.cont(result.value, isErr);</span><br><span class="line">      &#125;      </span><br><span class="line">    &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">      mainTask = taskStatus.ABORTED;</span><br><span class="line">      mainTask.cont(e, <span class="literal">true</span>); <span class="comment">// 任务出错时终止当前任务，并将错误信息向上传播</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">runEffect</span>(<span class="params">effect, currCb</span>)</span>&#123;</span><br><span class="line">    currCb.cancel = noop;</span><br><span class="line">    <span class="comment">//分情况处理effect：Promise, iterator, effect, 普通方法/变量</span></span><br><span class="line">    <span class="keyword">if</span>(is.iterator(effect))&#123;</span><br><span class="line">      proc(env, effect, currCb)</span><br><span class="line">    &#125; <span class="keyword">else</span> (is.promise(effect))&#123;</span><br><span class="line">      effect.then(currCb, <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        currCb(error, <span class="literal">true</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(effect &amp;&amp; effect.type) &#123;</span><br><span class="line">      <span class="keyword">let</span> effectRunner = effectRunnerMap[effect.type]; <span class="comment">// 选择runner执行effect</span></span><br><span class="line">      effectRunner(effect, currCb)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      currCb(effect)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">digestEffect</span>(<span class="params">effect, cb</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> settled = <span class="literal">false</span>; <span class="comment">// 如果当前effect已完成或者已取消则settled为true</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">currCb</span>(<span class="params">res, isErr</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(settled)&#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      settled = <span class="literal">true</span>;</span><br><span class="line">      cb.cancel = noop;</span><br><span class="line">      cb(res, isErr)</span><br><span class="line">    &#125;</span><br><span class="line">    cb.cancel = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(settled)&#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      settled = <span class="literal">true</span>;</span><br><span class="line">      currCb.cancel();</span><br><span class="line">      currCb.cancel = noop;</span><br><span class="line">    &#125;</span><br><span class="line">    runEffect(effect, currCb)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本节代码地址：<a href="https://github.com/xusanduo08/easy-saga/tree/master/%E5%86%99%E4%B8%80%E4%B8%AAredux-saga-2">https://github.com/xusanduo08/easy-saga/tree/master/%E5%86%99%E4%B8%80%E4%B8%AAredux-saga-2</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这节来写proc。proc主要功能是执行iterator。我们将一个generator的运行用一个task对象来表示。proc运行返回值即为task，代表当前的saga任务。taks内部有个taskQueue队列，管理着当前主任务mainTask以及子任务（fork任务，后</summary>
      
    
    
    
    
    <category term="redux-saga saga react redux" scheme="http://mengfansheng.com/tags/redux-saga-saga-react-redux/"/>
    
  </entry>
  
  <entry>
    <title>写一个redux-saga-1：saga基本结构</title>
    <link href="http://mengfansheng.com/2019/07/25/%E5%86%99%E4%B8%80%E4%B8%AAredux-saga-1_saga%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/"/>
    <id>http://mengfansheng.com/2019/07/25/%E5%86%99%E4%B8%80%E4%B8%AAredux-saga-1_saga%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/</id>
    <published>2019-07-25T01:42:59.000Z</published>
    <updated>2020-03-29T03:47:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>saga使用方法：</p><p>将异步操作（副作用）放在<code>yield</code>后面，操作完成后，saga会自动继续执行接下来的代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sagaMiddleware = createSagaMiddleware();</span><br><span class="line">createStore(reducers, &#123;&#125;, applyMiddleware(sagaMiddleware));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">rootSaga</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> take(<span class="string">&#x27;action-A&#x27;</span>);</span><br><span class="line">  <span class="keyword">yield</span> call(fetchData);</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">sagaMiddleware.run(rootSaga)</span><br></pre></td></tr></table></figure><p>所有一切的入口就在这一句：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sagaMiddleware.run(rootSaga)</span><br></pre></td></tr></table></figure><p>一句话：<code>run()</code>方法启动saga</p><p>saga结构大致有以下几个部分：</p><ul><li><p>sagaMiddlewareFactory：工厂方法，用来创建sagaMiddleware中间件</p></li><li><p>run：程序入口，将action传递到下一个中间件，同时启动rootSaga，并将rootSaga执行后返回的iterator传递给proc继续执行</p></li><li><p>proc：主要部分，用来执行Generator运行后产生的Iterator，负责触发iterator.next()，并根据每次执行返回的结果选择对应的runner来处理。</p></li><li><p>task：proc方法运行后的返回值，代表一次saga任务。</p></li><li><p>effects（位于io.js文件中）：定义用来产生effect的方法，例如我们用的<code>take</code>，<code>put</code>等方法，这些方法返回的结果都是一个effect。一个effect的结构如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">payload</span>:&#123;</span><br><span class="line">    fn, context</span><br><span class="line">    <span class="comment">// ... 需要传给effectRunner的参数</span></span><br><span class="line">  &#125;,</span><br><span class="line"><span class="attr">type</span>: effectType <span class="comment">// TAKE, PUT, CALL等</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>effectRunner（位于effectRunnerMap.js文件中）：这部分定义了用来执行每种类型effect的方法，例如，<code>take()</code>操作产生的effect需要<code>takeEffectRunner()</code>方法来执行</p></li><li><p>channel（位于channel.js文件中）：通道定义文件，通道可用于saga之间的通信和缓存消息</p></li><li><p>forkQueue（位于forkQueue.js文件中）：定义了管理fork task的队列，<code>fork()</code>方法会创建另一个task，产生的task会由forkQueue来管理</p></li><li><p>util（位于utils.js文件中）：定义了一些工具方法，如<code>resolvePromise()</code>、<code>remove()</code>等。</p></li></ul><p>下面写一下saga的工厂函数：<code>sagaMiddlewareFactory()</code>，用来创建saga中间件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sagaMiddlewareFactory</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">sagaMiddleware</span>(<span class="params">&#123;getState, dispatch&#125;</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">next</span> =&gt;</span> <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">      next(action);</span><br><span class="line">      <span class="comment">/**TODO action经过我们的中间件*/</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  sagaMiddleware.run = <span class="function">(<span class="params">saga</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 启动saga</span></span><br><span class="line">    <span class="comment">// 将iterator传入proc方法继续执行</span></span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">return</span> sagaMiddleware</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是<code>sagaMiddlewareFactory()</code>的大概样子。</p><p>saga中间件在获取到action后，需要决定是否要采取相应的动作，因此事先我们需要将action以及需要采取的动作注册到saga中间件某处—–如上所说我们将action以及需要采取的动作注册到channel中。（个人理解：想象一下，有个管道，action和对应的动作像“滤网”一样存在于管道中。当外界的action从管道中流过时，那些有相同action的滤网就会被击中，对应的操作就会被触发，同时管道中action被击中一次后就会被移除管道）</p><p>来定义一个channel。channel要有一个可以注册action和动作的方法，还要有一个能将接收到的action推入管道的方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stdChannel</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> takers = []; <span class="comment">// 用来放置action和cb</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">put</span>(<span class="params">action</span>)</span>&#123; <span class="comment">// 将action推入管道</span></span><br><span class="line">  <span class="keyword">let</span> currTakers = takers.concat([]); <span class="comment">// 防止遍历的时候takers发生变化</span></span><br><span class="line">  <span class="keyword">let</span> desTakes = []; <span class="comment">// 用来保存回调已经被执行的taker的索引，遍历结束后用来过滤takers</span></span><br><span class="line">  currTakers.forEach(<span class="function">(<span class="params">take, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(take.action.type === action.type)&#123;</span><br><span class="line">      desTakes.push(index);</span><br><span class="line">      cb(action);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  takers = takers.filter(<span class="function">(<span class="params">item, index</span>) =&gt;</span> !(desTakes.indexOf(index) &gt;=<span class="number">0</span>));</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">take</span>(<span class="params">action, cb</span>)</span>&#123; <span class="comment">// 注册action和对应的操作cb</span></span><br><span class="line">    takers.push(&#123;action, cb&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    put,</span><br><span class="line">    take</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来将管道应用到<code>sagaMiddlewareFactory()</code>中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sagaMiddlewareFactory</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> channel = stdChannel();</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">sagaMiddleware</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">next</span> =&gt;</span> <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">      next(action);</span><br><span class="line">      channel.put(action); <span class="comment">// 将action推入管道</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  sagaMiddleware.run = <span class="function">(<span class="params">saga</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> iterator = saga(); <span class="comment">// 启动saga</span></span><br><span class="line">    <span class="keyword">return</span> proc(iterator); <span class="comment">// proc处理iterator，下节会写</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sagaMiddleware;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本节代码地址：<a href="https://github.com/xusanduo08/easy-saga/tree/master/%E5%86%99%E4%B8%80%E4%B8%AAredux-saga-1">https://github.com/xusanduo08/easy-saga/tree/master/%E5%86%99%E4%B8%80%E4%B8%AAredux-saga-1</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;saga使用方法：&lt;/p&gt;
&lt;p&gt;将异步操作（副作用）放在&lt;code&gt;yield&lt;/code&gt;后面，操作完成后，saga会自动继续执行接下来的代码。&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=</summary>
      
    
    
    
    
    <category term="redux-saga react redux" scheme="http://mengfansheng.com/tags/redux-saga-react-redux/"/>
    
  </entry>
  
  <entry>
    <title>构建自己的React(1):Rendering DOM elements</title>
    <link href="http://mengfansheng.com/2019/07/10/%E6%9E%84%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84React-1-Rendering-DOM-elements/"/>
    <id>http://mengfansheng.com/2019/07/10/%E6%9E%84%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84React-1-Rendering-DOM-elements/</id>
    <published>2019-07-10T14:07:11.000Z</published>
    <updated>2020-03-29T03:47:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>翻译自这里：<a href="https://engineering.hexacta.com/didact-rendering-dom-elements-91c9aa08323b">https://engineering.hexacta.com/didact-rendering-dom-elements-91c9aa08323b</a><br>本系列的目的是创建类似于React的一个简易的工具库。</p><h4 id="DOM-review"><a href="#DOM-review" class="headerlink" title="DOM review"></a>DOM review</h4><p>开始之前，我们先看下我们要用到的DOM API：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过id查找元素</span></span><br><span class="line"><span class="keyword">const</span> domRoot = <span class="built_in">document</span>.getElementById(<span class="string">&quot;root&quot;</span>);</span><br><span class="line"><span class="comment">// 根据执行标签名创建元素</span></span><br><span class="line"><span class="keyword">const</span> domInput = <span class="built_in">document</span>.createElement(<span class="string">&quot;input&quot;</span>);</span><br><span class="line"><span class="comment">// 设置元素属性</span></span><br><span class="line">domInput[<span class="string">&quot;type&quot;</span>] = <span class="string">&quot;text&quot;</span>;</span><br><span class="line">domInput[<span class="string">&quot;value&quot;</span>] = <span class="string">&quot;Hi world&quot;</span>;</span><br><span class="line">domInput[<span class="string">&quot;className&quot;</span>] = <span class="string">&quot;my-class&quot;</span>;</span><br><span class="line"><span class="comment">// 添加事件监听</span></span><br><span class="line">domInput.addEventListener(<span class="string">&quot;change&quot;</span>, <span class="function"><span class="params">e</span> =&gt;</span> alert(e.target.value));</span><br><span class="line"><span class="comment">// 创建文本节点</span></span><br><span class="line"><span class="keyword">const</span> domText = <span class="built_in">document</span>.createTextNode(<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="comment">// 设置节点内容</span></span><br><span class="line">domText[<span class="string">&quot;nodeValue&quot;</span>] = <span class="string">&quot;Foo&quot;</span>;</span><br><span class="line"><span class="comment">// 往页面上添加元素</span></span><br><span class="line">domRoot.appendChild(domInput);</span><br><span class="line"><span class="comment">// 往页面上添加文本节点</span></span><br><span class="line">domRoot.appendChild(domText);</span><br></pre></td></tr></table></figure><p>注意到这里我们给元素设置了properties而不是attributes，而且只有有效的properties才能被设置。</p><h4 id="Didact-Elements"><a href="#Didact-Elements" class="headerlink" title="Didact Elements"></a>Didact Elements</h4><p>我们用原生的JS对象来描述我们要渲染的东西，并称这类对象为Didact Elements。这些元素对应的JS对象都有两个必要的属性：<code>type</code>和<code>props</code>。<code>type</code>可以是个字符串也可以是一个函数，但在我们介绍组件之前我们先只使用字符串。<code>props</code>是一个可以为空（<code>null</code>）的对象。<code>props</code>下还可以含有<code>children</code>属性，<code>children</code>属性值为一个装有Didact Elements的数组。</p><blockquote><p>我们后面将会频繁的使用Didact Elements，所以我们会用元素称呼Didact Elements。不要和HTML的元素搞混了，HTML元素会被称作DOM元素或者使用命名变量时干脆就叫<code>dom</code>。</p></blockquote><p>举个例子，我们会用下面这个对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = &#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&quot;div&quot;</span>,</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="string">&quot;container&quot;</span>,</span><br><span class="line">    <span class="attr">children</span>: [</span><br><span class="line">      &#123; <span class="attr">type</span>: <span class="string">&quot;input&quot;</span>, <span class="attr">props</span>: &#123; <span class="attr">value</span>: <span class="string">&quot;foo&quot;</span>, <span class="attr">type</span>: <span class="string">&quot;text&quot;</span> &#125; &#125;,</span><br><span class="line">      &#123; <span class="attr">type</span>: <span class="string">&quot;a&quot;</span>, <span class="attr">props</span>: &#123; <span class="attr">href</span>: <span class="string">&quot;/bar&quot;</span> &#125; &#125;,</span><br><span class="line">      &#123; <span class="attr">type</span>: <span class="string">&quot;span&quot;</span>, <span class="attr">props</span>: &#123;&#125; &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>来描述下面这个dom：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;container&quot;</span>&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">&quot;foo&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/bar&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>Didact Elements和React Elements很像。但通常情况下你不会使用JS手动去创建一个React Elements，更多的是使用JSX或者是<code>createElement</code>方法来创建。在Didact中我们也会使用相同的方法创建元素，但会将这部分内容放在下一节。</p><h4 id="Render-DOM-Elements"><a href="#Render-DOM-Elements" class="headerlink" title="Render DOM Elements"></a>Render DOM Elements</h4><p>下一步是将元素及其子元素渲染成dom。我们使用<code>render</code>（类似于<code>ReactDOM.render</code>）方法来接收一个元素和一个dom容器。这个方法会将这个元素描述的dom结构创建出来，并添加到容器内。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">element, parentDom</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; type, props &#125; = element;</span><br><span class="line">    <span class="keyword">const</span> dom = <span class="built_in">document</span>.createElement(type);</span><br><span class="line">    <span class="keyword">const</span> childElements = props.children || [];</span><br><span class="line">    childElements.forEach(<span class="function"><span class="params">childElement</span> =&gt;</span> render(childElement, dom));</span><br><span class="line">    parentDom.appendChild(dom);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们现在仍没有处理属性和事件。我们先用<code>Object.keys</code>来获取<code>props</code>中的属性名字，然后循环将它们设定到元素上：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">element, parentDom</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; type, props &#125; = element;</span><br><span class="line">    <span class="keyword">const</span> dom = <span class="built_in">document</span>.createElement(type);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> isListener = <span class="function"><span class="params">name</span> =&gt;</span> name.startsWith(<span class="string">&quot;on&quot;</span>);</span><br><span class="line">    <span class="built_in">Object</span>.keys(props).filter(isListener).forEach(<span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> eventType = name.toLowerCase().substring(<span class="number">2</span>);</span><br><span class="line">        dom.addEventListener(eventType, props[name]);</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> isAttribute = <span class="function"><span class="params">name</span> =&gt;</span> !isListener(name) &amp;&amp; name != <span class="string">&quot;children&quot;</span>;</span><br><span class="line">    <span class="built_in">Object</span>.keys(props).filter(isAttribute).forEach(<span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">        dom[name] = props[name];</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> childElements = props.children || [];</span><br><span class="line">    childElements.forEach(<span class="function"><span class="params">childElement</span> =&gt;</span> render(childElement, dom));</span><br><span class="line">    parentDom.appendChild(dom);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Render-DOM-Text-Nodes"><a href="#Render-DOM-Text-Nodes" class="headerlink" title="Render DOM Text Nodes"></a>Render DOM Text Nodes</h4><p>目前<code>render</code>还不支持文本节点。首先我们要定义文本节点是什么样的。在react中，一个<code>&lt;span&gt;Foo&lt;/span&gt;</code>这样的元素需要这样描述：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reactElement = &#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&quot;span&quot;</span>,</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">children</span>: [<span class="string">&quot;Foo&quot;</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到这里的子元素已经不是对象，而只是一个字符串。这和我们对Didact Elements的定义有不一样：<code>children</code>应该是装有Didact Elements的数组，并且所有元素都有<code>type</code>和<code>props</code>属性。如果我们继续遵守这个规则接下来我们将较少使用<code>if</code>的次数。所以，Didact Elements将会使用<code>type=&quot;TEXT_ELEMENT&quot;</code>来表示文本节点，并使用<code>nodeValue</code>来装文本值。例如下面这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> textElement = &#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&quot;span&quot;</span>,</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">children</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&quot;TEXT_ELEMENT&quot;</span>,</span><br><span class="line">        <span class="attr">props</span>: &#123; <span class="attr">nodeValue</span>: <span class="string">&quot;Foo&quot;</span> &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在我们已经定义好了能够渲染的文本节点。和其他节点不同的是，文本节点需要使用<code>createTextNode</code>来创建而不是<code>createElement</code>，而<code>nodeValue</code>会通过相同方法来设置。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">element, parentDom</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; type, props &#125; = element;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建DOM</span></span><br><span class="line">  <span class="keyword">const</span> isTextElement = type === <span class="string">&quot;TEXT_ELEMENT&quot;</span>;</span><br><span class="line">  <span class="keyword">const</span> dom = isTextElement</span><br><span class="line">    ? <span class="built_in">document</span>.createTextNode(<span class="string">&quot;&quot;</span>)</span><br><span class="line">    : <span class="built_in">document</span>.createElement(type);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加事件监听</span></span><br><span class="line">  <span class="keyword">const</span> isListener = <span class="function"><span class="params">name</span> =&gt;</span> name.startsWith(<span class="string">&quot;on&quot;</span>);</span><br><span class="line">  <span class="built_in">Object</span>.keys(props).filter(isListener).forEach(<span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> eventType = name.toLowerCase().substring(<span class="number">2</span>);</span><br><span class="line">    dom.addEventListener(eventType, props[name]);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置属性</span></span><br><span class="line">  <span class="keyword">const</span> isAttribute = <span class="function"><span class="params">name</span> =&gt;</span> !isListener(name) &amp;&amp; name != <span class="string">&quot;children&quot;</span>;</span><br><span class="line">  <span class="built_in">Object</span>.keys(props).filter(isAttribute).forEach(<span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">    dom[name] = props[name];</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 递归渲染子元素</span></span><br><span class="line">  <span class="keyword">const</span> childElements = props.children || [];</span><br><span class="line">  childElements.forEach(<span class="function"><span class="params">childElement</span> =&gt;</span> render(childElement, dom));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将dom添加到父dom内</span></span><br><span class="line">  parentDom.appendChild(dom);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h4><p>我们目前创建了一个可以渲染元素及其子元素为DOM的<code>render</code>方法。下一步我们需要一个快速简单的方法来创建元素。下一节我们将在Didact中使用JSX。</p><p>下一节：</p><p><a href="https://engineering.hexacta.com/didact-element-creation-and-jsx-d05171c55c56">https://engineering.hexacta.com/didact-element-creation-and-jsx-d05171c55c56</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;翻译自这里：&lt;a href=&quot;https://engineering.hexacta.com/didact-rendering-dom-elements-91c9aa08323b&quot;&gt;https://engineering.hexacta.com/didact-renderi</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>构建自己的React(2):Element creation and JSX.md</title>
    <link href="http://mengfansheng.com/2019/06/25/%E6%9E%84%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84React-2-Element-creation-and-JSX-md/"/>
    <id>http://mengfansheng.com/2019/06/25/%E6%9E%84%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84React-2-Element-creation-and-JSX-md/</id>
    <published>2019-06-25T13:59:21.000Z</published>
    <updated>2020-03-29T03:47:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>翻译自这里：<a href="https://engineering.hexacta.com/didact-element-creation-and-jsx-d05171c55c56">https://engineering.hexacta.com/didact-element-creation-and-jsx-d05171c55c56</a></p><h4 id="Didact-Element-creation-and-JSX"><a href="#Didact-Element-creation-and-JSX" class="headerlink" title="Didact: Element creation and JSX"></a>Didact: Element creation and JSX</h4><h4 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h4><p>上一节我们介绍了Didact Elements，使用了一种很麻烦的方法来代表要渲染的DOM。这一节我们将介绍如何使用JSX来创建Didact Elements。</p><p>下面是一个Didact Elements的原生对象表示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = &#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&quot;div&quot;</span>,</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="string">&quot;container&quot;</span>,</span><br><span class="line">    <span class="attr">children</span>: [</span><br><span class="line">      &#123; <span class="attr">type</span>: <span class="string">&quot;input&quot;</span>, <span class="attr">props</span>: &#123; <span class="attr">value</span>: <span class="string">&quot;foo&quot;</span>, <span class="attr">type</span>: <span class="string">&quot;text&quot;</span> &#125; &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&quot;a&quot;</span>,</span><br><span class="line">        <span class="attr">props</span>: &#123;</span><br><span class="line">          <span class="attr">href</span>: <span class="string">&quot;/bar&quot;</span>,</span><br><span class="line">          <span class="attr">children</span>: [&#123; <span class="attr">type</span>: <span class="string">&quot;TEXT_ELEMENT&quot;</span>, <span class="attr">props</span>: &#123; <span class="attr">nodeValue</span>: <span class="string">&quot;bar&quot;</span> &#125; &#125;]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&quot;span&quot;</span>,</span><br><span class="line">        <span class="attr">props</span>: &#123;</span><br><span class="line">          <span class="attr">onClick</span>: <span class="function"><span class="params">e</span> =&gt;</span> alert(<span class="string">&quot;Hi&quot;</span>),</span><br><span class="line">          <span class="attr">children</span>: [&#123; <span class="attr">type</span>: <span class="string">&quot;TEXT_ELEMENT&quot;</span>, <span class="attr">props</span>: &#123; <span class="attr">nodeValue</span>: <span class="string">&quot;click me&quot;</span> &#125; &#125;]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>有了JSX这个语法糖之后我们就可以使用下面这个方法来创建和上面一样的元素：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">&quot;foo&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/bar&quot;</span>&gt;</span>bar<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">onClick</span>=<span class="string">&#123;e</span> =&gt;</span> alert(&quot;Hi&quot;)&#125;&gt;click me<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>如果你对JSX不熟悉你可以能会想上面这段代码是个无效的JS对象—–没错，你想的是对的。为了让浏览器能解析JSX，我们需要使用预处理器（比如babel，想对JSX有更多了解的可以看<a href="https://jasonformat.com/wtf-is-jsx/">这里</a>）来将JSX转换一下。例如babel会将上面的JSX转成下面这个样子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = createElement(</span><br><span class="line">  <span class="string">&quot;div&quot;</span>,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="string">&quot;container&quot;</span> &#125;,</span><br><span class="line">  createElement(<span class="string">&quot;input&quot;</span>, &#123; <span class="attr">value</span>: <span class="string">&quot;foo&quot;</span>, <span class="attr">type</span>: <span class="string">&quot;text&quot;</span> &#125;),</span><br><span class="line">  createElement(</span><br><span class="line">    <span class="string">&quot;a&quot;</span>,</span><br><span class="line">    &#123; <span class="attr">href</span>: <span class="string">&quot;/bar&quot;</span> &#125;,</span><br><span class="line">    <span class="string">&quot;bar&quot;</span></span><br><span class="line">  ),</span><br><span class="line">  createElement(</span><br><span class="line">    <span class="string">&quot;span&quot;</span>,</span><br><span class="line">    &#123; <span class="attr">onClick</span>: <span class="function"><span class="params">e</span> =&gt;</span> alert(<span class="string">&quot;Hi&quot;</span>) &#125;,</span><br><span class="line">    <span class="string">&quot;click me&quot;</span></span><br><span class="line">  )</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>剩下我们要做的就是添加一个<code>createElement</code>方法来让Didact支持JSX，其他的工作就可以交给预处理器了。<code>createElement</code>方法的第一个参数是元素的类型<code>type</code>，第二个参数是元素的props对象，剩下的其他参数就是<code>children</code>了。<code>createElement</code>方法会返回带有<code>type</code>属性和<code>props</code>属性的对象，<code>props</code>属性值也是一个对象，该对象含有第二个参数的所有属性，第二个参数之后的其他参数会放在一个数组中，并作为该对象的<code>children</code>属性值。来实现一下<code>createElement</code>方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createElement</span>(<span class="params">type, config, ...args</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> props = <span class="built_in">Object</span>.assign(&#123;&#125;, config);</span><br><span class="line">    <span class="keyword">const</span> hasChildren = args.length &gt; <span class="number">0</span>;</span><br><span class="line">    props.children = hasChildren ? [].concat(...args) : [];</span><br><span class="line">    <span class="keyword">return</span> &#123;type, props&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的<code>createElement</code>在不碰到文本元素时都能很好的工作。遇到文本元素时，文本内容会以字符串形式在第二个参数之后传递给<code>createElement</code>。又因为我们之前定义了文本元素也需要有<code>type</code>和<code>props</code>属性，所以我们会将刚传进来的字符串转成一个文本元素。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> TEXT_ELEMENT = <span class="string">&#x27;TEXT_ELEMENT&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createElement</span>(<span class="params">type, config, ...args</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> props = <span class="built_in">Object</span>.assign(&#123;&#125;, config);</span><br><span class="line">    <span class="keyword">const</span> hasChildren = args.length &gt; <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> rawChildren = hasChildren ? [].concat(...args) : [];</span><br><span class="line">    props.children = rawChildren.filter(<span class="function"><span class="params">c</span> =&gt;</span> c != <span class="literal">null</span> &amp;&amp; c !== <span class="literal">false</span>)</span><br><span class="line">    .map(<span class="function"><span class="params">c</span> =&gt;</span> c <span class="keyword">instanceof</span> <span class="built_in">Object</span> ? c : createTextElement(c));</span><br><span class="line">    <span class="keyword">return</span> &#123; type, props &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createTextElement</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> createElement(TEXT_ELEMENT, &#123; <span class="attr">nodeValue</span>: value&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码排除了子元素为<code>null</code>， <code>undefined</code>和<code>false</code>的情况。这些情况都是没必要渲染的，所以也不需要添加到<code>props.children</code>上。</p><h4 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h4><p>这一节我们依然没有添加主功能到Didact上，但现在我们已经开始使用JSX来创建元素了，这大幅提升了开发体验。我已经将上节和本节的代码在<a href="https://codepen.io/pomber/pen/xdmoWE?editors=0010">codepen</a>上更新了。代码头部的注释<code>/** @jsx crerateElement8/</code>告诉了babel去使用<code>createElement</code>来转义JSX。</p><p>你也可以在这里查看<a href="https://github.com/pomber/didact/commit/15010f8e7b8b54841d1e2dd9eacf7b3c06b1a24b">代码</a>。</p><p>下一节我们将往Didact中加入虚拟DOM和用来支持更新操作的一致性校验算法。</p><p><a href="https://engineering.hexacta.com/didact-instances-reconciliation-and-virtual-dom-9316d650f1d0">下一节</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;翻译自这里：&lt;a href=&quot;https://engineering.hexacta.com/didact-element-creation-and-jsx-d05171c55c56&quot;&gt;https://engineering.hexacta.com/didact-eleme</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>构建自己的React(3):Instances,reconciliation and virtual DOM</title>
    <link href="http://mengfansheng.com/2019/06/20/%E6%9E%84%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84React-3-Instances-reconciliation-and-virtual-DOM/"/>
    <id>http://mengfansheng.com/2019/06/20/%E6%9E%84%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84React-3-Instances-reconciliation-and-virtual-DOM/</id>
    <published>2019-06-20T14:01:20.000Z</published>
    <updated>2020-03-29T03:47:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>翻译自这里：<a href="https://engineering.hexacta.com/didact-instances-reconciliation-and-virtual-dom-9316d650f1d0">https://engineering.hexacta.com/didact-instances-reconciliation-and-virtual-dom-9316d650f1d0</a></p><h4 id="Didact-Instances-reconciliation-and-virtual-DOM"><a href="#Didact-Instances-reconciliation-and-virtual-DOM" class="headerlink" title="Didact:Instances, reconciliation and virtual DOM"></a>Didact:Instances, reconciliation and virtual DOM</h4><p>截止目前我们已经可以使用JSX来创建并渲染页面DOM。在这一节我们将会把重点放在如何更新DOM上。</p><p>在介绍<code>setState</code>之前，更新DOM只能通过更改入参并再次调用<code>render</code>方法来实现。如果我们想实现一个时钟，代码大概下面这个样子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> rootDom = <span class="built_in">document</span>.getElementById(<span class="string">&quot;root&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> time = <span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleTimeString();</span><br><span class="line">  <span class="keyword">const</span> clockElement = <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;time&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">  render(clockElement, rootDom);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tick();</span><br><span class="line"><span class="built_in">setInterval</span>(tick, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>事实上，上面的代码运行后并不能达到预期的效果，多次调用当前版本的<code>render</code>方法只会不断往页面上添加新的元素，而不是我们预期的更新已经存在的元素。下面我们想办法实现更新操作。在<code>render</code>方法末尾，我们可以去检查父类元素是否含有子元素，如果有，我们就用新生成的元素去替换旧的元素。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">element, parentDom</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// Create dom from element</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span>(!parentDom.lastChild)&#123;</span><br><span class="line">        parentDom.appendChild(dom);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        parentDom.replaceChild(dom, parentDom.lastChild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对开头那个时钟的例子，上面<code>render</code>的实现是没问题的。但对于更复杂的情况，比如有多个子元素时上面代码就不能满足要求了。正确的做法是我们需要比较前后两次调用<code>render</code>方法时所生成的元素树，对比差异后只更新有变化的部分。</p><h4 id="Virtual-DOM-and-Reconciliation"><a href="#Virtual-DOM-and-Reconciliation" class="headerlink" title="Virtual DOM and Reconciliation"></a>Virtual DOM and Reconciliation</h4><p>React把一致性校验的过程称作“diffing”，我们要做的和React一样。首先需要把当前的元素树保存起来以便和后面新的元素树比较，也就是说，我们需要把当前页面内容所对应的虚拟DOM保存下来。</p><p>这颗虚拟DOM树的节点有必要讨论一下。一种选择是使用Didact Elements，它们已经含有<code>props.children</code>属性，我们可以根据这个属性构建出虚拟DOM树。现在有两个问题摆在面前：首先，为了方便比较，我们需要保存每个虚拟DOM指向的真实DOM的引用（校验过程中我们有需要会去更新实际DOM的属性），并且元素还要是不可变的；第二，目前元素还不支持含有内部状态（state）的组件。</p><h4 id="Instances"><a href="#Instances" class="headerlink" title="Instances"></a>Instances</h4><p>我们需要引入一个新的概念—–instances—–来解决上面的问题。一个实例表示一个已经渲染到DOM的元素，它是含有<code>element</code>，<code>dom</code>和<code>childInstances</code>属性的一个JS对象。<code>childInstances</code>是由子元素对应实例组成的数组。</p><blockquote><p>注意，这里说的实例和Dan Abramov在<a href="https://medium.com/@dan_abramov/react-components-elements-and-instances-90800811f8ca">React Components, Elements, and Instances</a>中提到的实例并不是一回事。Dan说的是公共实例，是调用继承自<code>React.Component</code>的组件的构造函数后返回的东西。我们将在后面的章节添加公共实例。</p></blockquote><p>每个DOM节点都会有对应的实例。一致性校验的目的之一就是尽量避免去创建或者移除实例。创建和移除实例意味着我们要修改DOM树，所以我们越多的重用实例就会越少的去修改DOM树。</p><h4 id="Refactoring"><a href="#Refactoring" class="headerlink" title="Refactoring"></a>Refactoring</h4><p>接下来我们来重构<code>render</code>方法，增加一致性校验算法，同时增加一个<code>instantiate</code>方法来为元素创建实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> rootInstance = <span class="literal">null</span>; <span class="comment">// 用来保存上一次调用render产生的实例</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">element, container</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> prevInstance = rootInstance;</span><br><span class="line">    <span class="keyword">const</span> nextInstance = reconcile(container, prevInstance, element);</span><br><span class="line">    rootInstance = nextInstace;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 目前只是针对根元素的校验，没有处理到子元素</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reconcile</span>(<span class="params">parentDom, instance, element</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(instance === <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">const</span> newInstance = instantiate(element);</span><br><span class="line">        parentDom.appendChild(newInstance.dom);</span><br><span class="line">        <span class="keyword">return</span> newInstance;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> newInstance = instantiate(element);</span><br><span class="line">        parentDom.replaceChild(newInstance.dom, instance.dom);</span><br><span class="line">        <span class="keyword">return</span> newInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成元素对应实例的方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">instantiate</span>(<span class="params">element</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; type, props&#125; = element;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> isTextElement = type === <span class="string">&#x27;TEXT_ELEMENT&#x27;</span>;</span><br><span class="line">    <span class="keyword">const</span> dom = isTextElement ? <span class="built_in">document</span>.createTextNode(<span class="string">&#x27;&#x27;</span>) </span><br><span class="line">    : <span class="built_in">document</span>.createElement(type);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加事件</span></span><br><span class="line">    <span class="keyword">const</span> isListener = <span class="function"><span class="params">name</span> =&gt;</span> name.startsWith(<span class="string">&quot;on&quot;</span>);</span><br><span class="line">    <span class="built_in">Object</span>.keys(props).filter(isListener).forEach(<span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> eventType = name.toLowerCase().substring(<span class="number">2</span>);</span><br><span class="line">        dom.addEventListener(eventType, props[name]);</span><br><span class="line">     &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置属性</span></span><br><span class="line">  <span class="keyword">const</span> isAttribute = <span class="function"><span class="params">name</span> =&gt;</span> !isListener(name) &amp;&amp; name != <span class="string">&quot;children&quot;</span>;</span><br><span class="line">  <span class="built_in">Object</span>.keys(props).filter(isAttribute).forEach(<span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">    dom[name] = props[name];</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> childElements = props.children || [];</span><br><span class="line">  <span class="keyword">const</span> childInstances = childElements.map(instantiate);</span><br><span class="line">  <span class="keyword">const</span> childDoms = childInstances.map(<span class="function"><span class="params">childInstance</span> =&gt;</span> childInstace.dom);</span><br><span class="line">  childDoms.forEach(<span class="function"><span class="params">childDom</span> =&gt;</span> dom.appendChild(childDOm));</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> instance = &#123;dom, element, childInstances&#125;;</span><br><span class="line">  <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的<code>render</code>方法和之前的差不多，不同之处是保存了上次调用<code>render</code>方法产生的实例。我们还把一致性校验的功能从创建实例的代码中分离了出来。</p><p>为了重用dom节点，我们需要一个能更新dom属性的方法，这样就不用每次都创建新的dom节点了。我们来改造一下现有代码中设置属性的那部分的代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">instantiate</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; type, props &#125; = element;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建DOM元素</span></span><br><span class="line">  <span class="keyword">const</span> isTextElement = type === <span class="string">&#x27;TEXT_ELEMENT&#x27;</span>;</span><br><span class="line">  <span class="keyword">const</span> dom = isTextElement</span><br><span class="line">    ? <span class="built_in">document</span>.createTextNode(<span class="string">&quot;&quot;</span>)</span><br><span class="line">    : <span class="built_in">document</span>.createElement(type);</span><br><span class="line"></span><br><span class="line">  updateDomProperties(dom, [], props); <span class="comment">// 实例化一个新的元素</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 实例化并添加子元素</span></span><br><span class="line">  <span class="keyword">const</span> childElements = props.children || [];</span><br><span class="line">  <span class="keyword">const</span> childInstances = childElements.map(instantiate);</span><br><span class="line">  <span class="keyword">const</span> childDoms = childInstances.map(<span class="function"><span class="params">childInstance</span> =&gt;</span> childInstance.dom);</span><br><span class="line">  childDoms.forEach(<span class="function"><span class="params">childDom</span> =&gt;</span> dom.appendChild(childDom));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> instance = &#123; dom, element, childInstances &#125;;</span><br><span class="line">  <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateDomProperties</span>(<span class="params">dom, prevProps, nextProps</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> isEvent = <span class="function"><span class="params">name</span> =&gt;</span> name.startsWith(<span class="string">&#x27;on&#x27;</span>);</span><br><span class="line">   <span class="keyword">const</span> isAttribute = <span class="function"><span class="params">name</span> =&gt;</span> !isEvent(name) &amp;&amp; name != <span class="string">&#x27;children&#x27;</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="built_in">Object</span>.keys(prevProps).filter(isEvent).forEach(<span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> eventType = name.toLowerCase().substring(<span class="number">2</span>);</span><br><span class="line">        dom.removeEventListener(eventType, prevProps[name]);</span><br><span class="line">   &#125;);</span><br><span class="line">   </span><br><span class="line">   <span class="built_in">Object</span>.keys(preProps).filter(isAttribute).forEach(<span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">        dom[name] = nextProps[name];</span><br><span class="line">   &#125;);</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 设置属性</span></span><br><span class="line">  <span class="built_in">Object</span>.keys(nextProps).filter(isAttribute).forEach(<span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">    dom[name] = nextProps[name];</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加事件监听</span></span><br><span class="line">  <span class="built_in">Object</span>.keys(nextProps).filter(isEvent).forEach(<span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> eventType = name.toLowerCase().substring(<span class="number">2</span>);</span><br><span class="line">    dom.addEventListener(eventType, nextProps[name]);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>updateDomProperties</code>方法会移除所有旧的属性，然后再添加新属性。如果属性没有变化的话依然会进行移除和添加操作，这一定程度上有些浪费，但我们先这样放着，后面再处理。</p><h4 id="Reusing-DOM-nodes"><a href="#Reusing-DOM-nodes" class="headerlink" title="Reusing DOM nodes"></a>Reusing DOM nodes</h4><p>前面说过，一致性校验算法需要尽可能多的去重用已经创建的节点。因为目前元素的<code>type</code>都是代表HTML中标签名的字符串，所以如果同一位置前后两次渲染的元素的类型一样则表示两者为同一类元素，对应的已经渲染到页面上的dom节点就可以被重用。下面我们在<code>reconcile</code>中增加判断前后两次渲染的元素类型是否相同的功能，相同的话执行更新操作，否则是新建或者替换。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reconcile</span>(<span class="params">parentDom, instance, element</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 创建实例</span></span><br><span class="line">    <span class="keyword">const</span> newInstance = instantiate(element);</span><br><span class="line">    parentDom.appendChild(newInstance.dom);</span><br><span class="line">    <span class="keyword">return</span> newInstance;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (instance.element.type === element.type) &#123; <span class="comment">// 和老的实例进行类型比较</span></span><br><span class="line">    <span class="comment">// 更新</span></span><br><span class="line">    updateDomProperties(instance.dom, instance.element.props, element.props);</span><br><span class="line">    instance.element = element;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果不相等的话直接替换</span></span><br><span class="line">    <span class="keyword">const</span> newInstance = instantiate(element);</span><br><span class="line">    parentDom.replaceChild(newInstance.dom, instance.dom);</span><br><span class="line">    <span class="keyword">return</span> newInstance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Children-Reconciliation"><a href="#Children-Reconciliation" class="headerlink" title="Children Reconciliation"></a>Children Reconciliation</h4><p>现在校验过程还没有对子元素进行处理。针对子元素的校验是React中的一个关键部分，这一过程需要元素的一个额外属性<code>key</code>来完成，如果某个元素在新旧虚拟DOM上的<code>key</code>值相同，则表示该元素没有发生变化，直接重用即可。在当前版本的代码中我们会遍历<code>instance.childInstances</code>和<code>element.props.children</code>，并对同一位置的实例和元素进行比较，通过这种方式完成对子元素的一致性校验。这种方法的缺点就是，如果子元素只是调换了位置，那么对应的DOM节点将没法重用。</p><p>我们把同一实例上一次的<code>instance.childInstances</code>和这次对应元素的<code>element.props.children</code>进行递归比较，并且保存每次<code>reconcile</code>返回的结果以便更新<code>childInstances</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reconcile</span>(<span class="params">parentDom, instance, element</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">       <span class="keyword">const</span> newInstance = instantiate(element);</span><br><span class="line">        parentDom.appendChild(newInstance.dom);</span><br><span class="line">        <span class="keyword">return</span> newInstance;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(instance.element.type === element.type)&#123;</span><br><span class="line">        updateDomProperties(instance.dom, instance.element.props, element.props);</span><br><span class="line">        instance.childInstances = reconcileChildren(instance, element);</span><br><span class="line">        instance.element = element;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> newInstance = instantiate(element);</span><br><span class="line">        parentDom.replaceChild(newInstance.dom, instance.dom);</span><br><span class="line">        <span class="keyword">return</span> newInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reconcileChildren</span>(<span class="params">instance, element</span>)</span>&#123;</span><br><span class="line"><span class="keyword">const</span> dom = instance.dom;</span><br><span class="line">    <span class="keyword">const</span> childInstances = instance.childInstances;</span><br><span class="line">    <span class="keyword">const</span> nextChildElements = element.props.children || [];</span><br><span class="line">    <span class="keyword">const</span> newChildInstances = [];</span><br><span class="line">    <span class="keyword">const</span> count = <span class="built_in">Math</span>.max(childInstances.length, nextChildElements.length);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i&lt; count; i++)&#123;</span><br><span class="line">        <span class="keyword">const</span> childInstance = childInstances[i]; </span><br><span class="line">        <span class="keyword">const</span> childElement = nextChildElements[i];<span class="comment">//上面一行和这一行都容易出现空指针，稍后处理</span></span><br><span class="line">        <span class="keyword">const</span> newChildInstance = reconcile(dom, childInstance, childElement);</span><br><span class="line">        newChildInstances.push(newChildInstance);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newChildInstances;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Removing-DOM-nodes"><a href="#Removing-DOM-nodes" class="headerlink" title="Removing DOM nodes"></a>Removing DOM nodes</h4><p>如果<code>nextChildElements</code>数量多于<code>childInstances</code>，那么对子元素进行一致性校验时就容易出现<code>undefined</code>与剩下的子元素进行比较的情况。不过这不是什么大问题，因为在<code>reconcile</code>中的<code>if(instance == null)</code>会处理这种情况，并且会根据多出来的元素创建新的实例。如果<code>childInstances</code>的数量多于<code>nextChildElement</code>，那么<code>reconcile</code>就会收到一个<code>undefined</code>作为其<code>element</code>参数，然后在尝试获取<code>element.type</code>时就会抛出错误。</p><p>出现这个错误是因为我们没有考虑DOM节点需要移除的情况。所以接下来我们要做两件事情，一个是在<code>reconcile</code>中增加增加<code>element === null</code>的校验，一个是在<code>reconcileChildren</code>中过滤掉值为<code>null</code>的<code>childInstances</code>元素。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reconcile</span>(<span class="params">parentDom, instance, element</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">const</span> newInstance = instantiate(element);</span><br><span class="line">        parentDom.appendChild(newInstance.dom);</span><br><span class="line">        <span class="keyword">return</span> Instance;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(element == <span class="literal">null</span>)&#123;</span><br><span class="line">        parentDom.removeChild(instance.dom);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 注意这地方返回null了</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(instance.element.type === element.type)&#123;</span><br><span class="line">        updateDomProperties(instance.dom, instance.element.props, element.props);</span><br><span class="line">        instance.childInstances = reconcileChildren(instance, element);</span><br><span class="line">        instance.element = element;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> newInstance = instantiate(element);</span><br><span class="line">        parentDom.replaceChild(newInstance.dom, instance.dom);</span><br><span class="line">        <span class="keyword">return</span> newInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reconcileChildren</span>(<span class="params">instance, element</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> dom = instance.dom;</span><br><span class="line">    <span class="keyword">const</span> childInstances = instance.childInstances;</span><br><span class="line">    <span class="keyword">const</span> nextChildElements = element.props.children || [];</span><br><span class="line">    <span class="keyword">const</span> newChildInstances = [];</span><br><span class="line">    <span class="keyword">const</span> count = <span class="built_in">Math</span>.max(childInstances.length, nextChildElements.length);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; count; i++)&#123;</span><br><span class="line">        <span class="keyword">const</span> childInstance = childInstances[i];</span><br><span class="line">        <span class="keyword">const</span> childElement = nextChildElements[i];</span><br><span class="line">        <span class="keyword">const</span> newChildInstances = reconcile(dom, childInstance, childElement);</span><br><span class="line">        newChildInstances.push(newChildInstance);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newChildInstances.filter(<span class="function"><span class="params">instance</span> =&gt;</span> instance != <span class="literal">null</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h4><p>这一节，我们为Didact增加了更新DOM的功能。我们通过重用节点，避免了频繁的创建和移除DOM节点，提高了Didact的工作效率。重用节点还有一定的好处，比如保存了DOM的位置或者焦点等一些内部状态信息。</p><p>目前我们是在根元素上调用<code>render</code>方法的，每次有变化时也是针对整棵元素树进行的一致性校验。<a href="https://engineering.hexacta.com/didact-components-and-state-53ab4c900e37">下一节</a>我们将介绍组件。有了组件我们就可以只针对有变化的那一部分子树进行一致性校验。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;翻译自这里：&lt;a href=&quot;https://engineering.hexacta.com/didact-instances-reconciliation-and-virtual-dom-9316d650f1d0&quot;&gt;https://engineering.hexacta.</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>构建自己的React(4):Components and State</title>
    <link href="http://mengfansheng.com/2019/06/16/%E6%9E%84%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84React-4-Components-and-State/"/>
    <id>http://mengfansheng.com/2019/06/16/%E6%9E%84%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84React-4-Components-and-State/</id>
    <published>2019-06-16T14:02:59.000Z</published>
    <updated>2020-03-29T03:47:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>翻译自这里：<a href="https://engineering.hexacta.com/didact-components-and-state-53ab4c900e37">https://engineering.hexacta.com/didact-components-and-state-53ab4c900e37</a></p><h4 id="Components-and-State"><a href="#Components-and-State" class="headerlink" title="Components and State"></a>Components and State</h4><p>上一节的代码有一些问题：</p><ul><li>每次更新都会带来整颗虚拟DOM树的一致性校验；</li><li>状态是全局的（没有私有状态）；</li><li>有变化发生后必须手动调用<code>render</code>方法以便将变化反应到页面上。</li></ul><p>组件可以帮我们解决上面的问题，同时还能带来一些新特性：</p><ul><li>允许自定义JSX的标签名</li><li>生命周期钩子（这一节暂不介绍这部分）</li></ul><p>首先我们要定义一个<code>Component</code>的基础类，在创建其它组件时都要继承该类。我们需要一个带有<code>props</code>入参和<code>setState</code>方法的构造函数，<code>setState</code>方法可以接收<code>partialState</code>作为入参来更新组件状态：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.props = props;</span><br><span class="line">        <span class="built_in">this</span>.state = <span class="built_in">this</span>.state || &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">setState</span>(<span class="params">partialState</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.state = <span class="built_in">Object</span>.assign(&#123;&#125;, <span class="built_in">this</span>.state, partialState);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在创建组件时都会继承上面这个类。组件的使用方法和原生的标签如<code>div</code>或者<code>span</code>一样，直接像这样<code>&lt;MyComponent /&gt;</code>就可以了。而且我们的<code>createElement</code>也不需要做修改，元素的<code>type</code>属性可以直接取值为组件类，剩下的<code>props</code>属性也不需要特别的处理。我们需要一个方法能根据传入的元素来创建组件的实例（称之为公共实例，其实就是根据这个构造函数new出来的一个对象）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPublicInstance</span>(<span class="params">element, internalInstance</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;type, props&#125; = element;</span><br><span class="line">    <span class="keyword">const</span> publicInstance = <span class="keyword">new</span> type(props); <span class="comment">// 这地方的type对应组件的构造函数</span></span><br><span class="line">    publicInstance.__internalInstance = internalInstance;</span><br><span class="line">    <span class="keyword">return</span> publicInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>组件的内部实例含有组件对应的dom元素（内部实例就是前几节我们说的实例，通过调用<code>instantiate</code>方法生成的）。公共实例与内部实例的引用关系会被保存着，通过这个引用关系可以找到公共实例对应的内部实例及虚拟DOM，当公共实例状态发生变化时，我们就可以只更新发生变化的内部实例及其对应的那部分虚拟DOM：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.props = props;</span><br><span class="line">        <span class="built_in">this</span>.state = <span class="built_in">this</span>.state || &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">setState</span>(<span class="params">partialState</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.state = <span class="built_in">Object</span>.assign(&#123;&#125;, <span class="built_in">this</span>.state, partialState);</span><br><span class="line">        updateInstance(<span class="built_in">this</span>.__internalInstance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateInstance</span>(<span class="params">internalInstance</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> parentDom = internalInstance.dom.parentNode;</span><br><span class="line">    <span class="keyword">const</span> element = internalInstance.element;</span><br><span class="line">    reconcile(parentDom, internalInstance, element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>instantiate</code>方法需要做一些改造。对组件来讲，我们需要先创建公共实例（先new一个组建），然后调用组件的<code>render</code>方法来获取组件内部的元素，最后把获取到的元素传递给<code>instantiate</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">instantiate</span>(<span class="params">element</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; type, props &#125; = element;</span><br><span class="line">    <span class="keyword">const</span> isDomElement = <span class="keyword">typeof</span> type === <span class="string">&#x27;string&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(isDomElement)&#123; <span class="comment">// 如果是原生的dom元素的话，直接创建实例</span></span><br><span class="line">        <span class="keyword">const</span> isTextElement = type === TEXT_ELEMENT;</span><br><span class="line">        <span class="keyword">const</span> dom = isTextElement</span><br><span class="line">        ? <span class="built_in">document</span>.createTextNode(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        : <span class="built_in">document</span>.createElement(type);</span><br><span class="line">         </span><br><span class="line">         updateDomProperties(dom, [], props);</span><br><span class="line">         </span><br><span class="line">         <span class="keyword">const</span> childElements = props.children || [];</span><br><span class="line">         <span class="keyword">const</span> childInstances = childElements.map(instantiate);</span><br><span class="line">         <span class="keyword">const</span> childDoms = childInstances.map(<span class="function"><span class="params">childInstance</span> =&gt;</span> childInstance.dom);</span><br><span class="line">         childDoms.forEach(<span class="function"><span class="params">childDom</span> =&gt;</span> dom.appendChild(childDom));</span><br><span class="line">         </span><br><span class="line">         <span class="keyword">const</span> instance = &#123; dom, element, childInstances &#125;;</span><br><span class="line">         <span class="keyword">return</span> instance;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">// 否则先创建公共实例，然后再调用instantiate方法创建内部实例</span></span><br><span class="line">        <span class="keyword">const</span> instance = &#123;&#125;;</span><br><span class="line">        <span class="comment">// 这地方的element是一个type属性为一个构造函数的对象</span></span><br><span class="line">        <span class="keyword">const</span> publicInstance = createPublicInstance(element, instance);</span><br><span class="line">        <span class="keyword">const</span> childElement = publicInstance.render();<span class="comment">//获取最新的子元素</span></span><br><span class="line">        <span class="keyword">const</span> childInstance = instantiate(childElement);</span><br><span class="line">        <span class="keyword">const</span> dom = childInstance.dom;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">Object</span>.assign(instance, &#123; dom, element, childInstance, publicInstance&#125;);</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>组件对应的内部实例和原生dom元素对应的实例有些不一样。组件内部实例只会拥有一个子元素，即<code>render</code>方法返回的内容，而原生dom元素则可以含有多个子元素。所以对于组件内部实例来讲，它们会有一个<code>childInstance</code>属性而不是一个<code>childInstances</code>数组。此外，由于在进行一致性校验时需要调用组件的<code>render</code>方法，所以组件内部实例会保存对公共实例的引用（反过来公共实例也保存着对内部实例的引用）。</p><p>接下来我们来处理下组件实例的一致性校验。因为组件的内部实例只含有一个子元素（所有元素有一个统一的父类），只需要更新公共实例的<code>props</code>属性，执行<code>render</code>方法获取子元素，然后再进行一致性校验就可以了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reconcile</span>(<span class="params">parentDom, instance, element</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">const</span> newInstance = instantiate(element);</span><br><span class="line">        parentDom.appendChild(newInstance.dom);</span><br><span class="line">        <span class="keyword">return</span> newInstance;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>( element == <span class="literal">null</span>)&#123;</span><br><span class="line">        parentDom.removeChild(instance.dom);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(instance.element.type !== element.type)&#123;</span><br><span class="line">        <span class="keyword">const</span> newInstance = instantiate(element);</span><br><span class="line">        parentDom.replaceChild(newInstance.dom, instance.dom);</span><br><span class="line">        <span class="keyword">return</span> newInstance;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">typeof</span> element.type === <span class="string">&#x27;string&#x27;</span>)&#123;</span><br><span class="line">        updateDomProperties(instance.dom, instance.element, props, element.props);</span><br><span class="line">        instance.childInstances = reconcileChildren(instance, element);</span><br><span class="line">        instance.element = element;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        instance.publicInstance.props = element.props;<span class="comment">// 更新公共实例的props</span></span><br><span class="line">        <span class="keyword">const</span> childElement = instance.publicInstance.render(); <span class="comment">// 获取最新的子元素</span></span><br><span class="line">        <span class="keyword">const</span> oldChildInstance = instance.childInstance;</span><br><span class="line">        <span class="keyword">const</span> childInstance = reconcile(parentDom, oldChildInstance, childElement);</span><br><span class="line">        </span><br><span class="line">        instance.dom = childInstance.dom;</span><br><span class="line">        instance.childInstance = childInstance;</span><br><span class="line">        instance.element = element;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们的Didact.js已经可以支持组件了。<a href="https://codepen.io/pomber/pen/RVqBrx">这里</a>可以在线编辑代码并能看到效果。</p><p>使用组件后，我们可以创建自定义的JSX标签，并拥有了组件内部状态，而且组件有变化时只会变更自己的那部分dom内容。</p><p>相关内容到此结束。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;翻译自这里：&lt;a href=&quot;https://engineering.hexacta.com/didact-components-and-state-53ab4c900e37&quot;&gt;https://engineering.hexacta.com/didact-component</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>防抖和节流</title>
    <link href="http://mengfansheng.com/2019/01/31/%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/"/>
    <id>http://mengfansheng.com/2019/01/31/%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/</id>
    <published>2019-01-31T11:28:59.000Z</published>
    <updated>2020-03-29T03:47:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>防抖和节流都是为了解决__短时间内大量触发某函数__而导致的性能问题。比如触发频率过高导致响应速度跟不上触发频率，页面出现延迟、假死或卡顿的现象。</p><p>__防抖__：在事件被触发n秒后再执行回调函数，如果在这n秒内事件被重新触发，则重新计时。</p><p>常见应用场景：输入框的keyup事件，window的resize、scroll事件等。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 防抖</span></span><br><span class="line"><span class="keyword">const</span> debounce = <span class="function"><span class="keyword">function</span>(<span class="params">fn, delay</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span>; <span class="comment">// 用来保存计时器</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">args</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> that = <span class="built_in">this</span>;</span><br><span class="line">        <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">        </span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            fn.call(that, args); <span class="comment">// 指定延迟后执行对应的回调函数</span></span><br><span class="line">        &#125;, delay)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// 如果debounce中传入的是箭头函数的话，会导致this一直指向window</span></span><br><span class="line"><span class="comment">// 因为箭头函数函数体内的this对象就是定义函数时所处的对象。</span></span><br><span class="line">inputNode.onkeyup = debounce(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.target.value)</span><br><span class="line">&#125;, <span class="number">500</span>)</span><br></pre></td></tr></table></figure><p>__节流__：在规定时间内，指定的事件回调只能被触发一次。如果在规定时间内，事件被多次触发，那么只有一次会生效。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 因为在某个时间段只能执行一次，我们需要保存上一次执行的时间点和定时器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, threshhold</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> start = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">args</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> that = <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">let</span> curr = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(curr - start &gt;= threshhold)&#123;</span><br><span class="line">            fn.call(that, args);</span><br><span class="line">            start = curr;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果操作的时间很短，没有达到节流的阈值，那么在指定时间后自动执行一次。</span></span><br><span class="line">            timer = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                fn.call(that, args);</span><br><span class="line">            &#125;, threshhold)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上是使用时间戳实现的节流，下面看一下使用定时器如何实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, threshhold</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">args</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> that = <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">if</span>(!timer)&#123;</span><br><span class="line">            timer = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                fn.call(that, args);</span><br><span class="line">                <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">                timer = <span class="literal">null</span>;</span><br><span class="line">            &#125;, delay)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.onmousemove = throttle(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.pageX, e.pageY);</span><br><span class="line">&#125;, <span class="number">200</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;防抖和节流都是为了解决__短时间内大量触发某函数__而导致的性能问题。比如触发频率过高导致响应速度跟不上触发频率，页面出现延迟、假死或卡顿的现象。&lt;/p&gt;
&lt;p&gt;__防抖__：在事件被触发n秒后再执行回调函数，如果在这n秒内事件被重新触发，则重新计时。&lt;/p&gt;
&lt;p&gt;常见应</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>广度优先和深度优先遍历DOM树</title>
    <link href="http://mengfansheng.com/2019/01/13/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E5%92%8C%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86DOM%E6%A0%91/"/>
    <id>http://mengfansheng.com/2019/01/13/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E5%92%8C%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86DOM%E6%A0%91/</id>
    <published>2019-01-13T13:43:28.000Z</published>
    <updated>2020-03-29T03:47:42.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;root&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">&quot;sidebar&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;menu&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">&quot;main&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">&quot;post&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;copyright&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对上面的DOM树进行广度优先的遍历，遍历到每个节点时，打印出当前节点的类型及类名，例如，上面DOM树广度优先遍历结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DIV root</span><br><span class="line">DIV container</span><br><span class="line">SECTION sidebar</span><br><span class="line">SECTION main</span><br><span class="line">UL menu</span><br><span class="line">ARTICLE post</span><br><span class="line">P copyright</span><br></pre></td></tr></table></figure><p><strong>广度优先遍历需要使用队列数据结构来管理待遍历的节点</strong></p><p>代码实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> traverse = <span class="function">(<span class="params">ndRoot</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">const</span> queue = [ndRoot];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (queue.length) &#123;</span><br><span class="line">    <span class="keyword">const</span> node = queue.shift();</span><br><span class="line"></span><br><span class="line">    printInfo(node);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!node.children.length) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Array</span>.from(node.children).forEach(<span class="function"><span class="params">x</span> =&gt;</span> queue.push(x));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> printInfo = <span class="function">(<span class="params">node</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(node.tagName, <span class="string">`<span class="subst">$&#123;node.className&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">traverse(<span class="built_in">document</span>.querySelector(<span class="string">&quot;.root&quot;</span>));</span><br></pre></td></tr></table></figure><p>补充：</p><ul><li>childNodes返回的是节点的子节点集合，包括元素节点、文本节点还有属性节点。</li><li>children返回的只是节点的元素节点集合。</li></ul><p>__增加深度优先遍历的代码__：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> t = <span class="built_in">document</span>.querySelector(<span class="string">&quot;.root&quot;</span>)</span><br><span class="line"><span class="keyword">var</span> stack = [];</span><br><span class="line">stack.push(t);</span><br><span class="line"><span class="keyword">var</span> node;</span><br><span class="line"><span class="keyword">while</span>(stack.length != <span class="number">0</span>)&#123;</span><br><span class="line">  node = stack.pop();</span><br><span class="line">  <span class="built_in">console</span>.log(node.tagName, node.className;</span><br><span class="line">  <span class="keyword">if</span>(!node.children.length)&#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="built_in">Array</span>.from(node.children).forEach( <span class="function"><span class="params">x</span> =&gt;</span> stack.push(x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码没有按照从上至下，从左到右的顺序遍历，修改成如下代码，__使用递归__：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用递归</span></span><br><span class="line"><span class="keyword">var</span> t = <span class="built_in">document</span>.querySelectorAll(<span class="string">&quot;.root&quot;</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">DeepthFirst</span>(<span class="params">t</span>)</span>&#123;</span><br><span class="line"><span class="keyword">while</span>(t.length != <span class="number">0</span>)&#123;</span><br><span class="line">      node = t.shift();</span><br><span class="line">      <span class="built_in">console</span>.log(node.tagName, node.className);</span><br><span class="line">      <span class="keyword">if</span>(node.children.length != <span class="number">0</span>)&#123;</span><br><span class="line">          DeepthFirst(<span class="built_in">Array</span>.from(node.children))</span><br><span class="line">      &#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">DeepthFirst(<span class="built_in">Array</span>.from(t));</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">DIV root</span></span><br><span class="line"><span class="comment">DIV container</span></span><br><span class="line"><span class="comment">SECTION sidebar</span></span><br><span class="line"><span class="comment">UL menu</span></span><br><span class="line"><span class="comment">SECTION main</span></span><br><span class="line"><span class="comment">ARTICLE post</span></span><br><span class="line"><span class="comment">P copyright</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>队列： 先进先出（FIFO）</p><p>栈：后进先出（LIFO）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>BFC&amp;IFC</title>
    <link href="http://mengfansheng.com/2019/01/09/BFC-IFC/"/>
    <id>http://mengfansheng.com/2019/01/09/BFC-IFC/</id>
    <published>2019-01-09T13:06:11.000Z</published>
    <updated>2020-03-29T03:47:42.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h4><p>处于__普通流（Normal Flow）__中的盒子都会属于一个格式化上下文（Formatting context），要么是__块级格式化上下文（Block formatting context，BFC）__，要么是__行内格式化上下文（Inline formatting context，IFC）__，但不会两者都是。__块级盒子参与的是BFC，行内盒子参与的是IFC__。</p><h4 id="position-schemes：定位策略"><a href="#position-schemes：定位策略" class="headerlink" title="position schemes：定位策略"></a><code>position schemes</code>：定位策略</h4><p>定位策略是影响盒子布局的因素之一。</p><p>一个盒子可以根据三种定位策略来渲染自身：</p><ul><li><code>normal flow</code>：普通流。在css2中，普通流包括处于BFC中的块级盒子、处于IFC中的行内盒子，还有相对定位的块级和行内盒子。</li><li><code>floats</code>：在浮动模式下，盒子首先会按照普通流来渲染，然后跳出普通流并尽可能的左右移动。</li><li><code>absolute position</code>：在绝对定位模式下，盒子会完全跳出普通流，它的位置会相对于有<code>position</code>属性的包含容器来定位，此时，绝对定位的盒子对后面兄弟盒子的布局没有影响。</li></ul><p>如果元素有浮动属性或者绝对定位属性，或者是一个根元素，那么我们就说这个元素是脱离普通流的（out of flow），而剩下的都叫处于普通流中（in-flow）</p><h4 id="通过position属性来选择定位策略"><a href="#通过position属性来选择定位策略" class="headerlink" title="通过position属性来选择定位策略"></a>通过<code>position</code>属性来选择定位策略</h4><p><code>position</code>属性有5个值：<code>static</code>、<code>relative</code>、<code>absolute</code>、<code>fixed</code>、<code>inherit</code></p><ul><li><code>static</code>、<code>relative</code>：这两种情况下盒子都处于普通流中。<code>static</code>为<code>position</code>属性的默认值，此时元素的<code>top</code>、<code>left</code>、<code>bottom</code>、<code>right</code>不会起作用。<code>position:relative</code>的盒子，它的位置会相对于自身处于正常模式下的位置根据<code>top</code>、<code>left</code>、<code>bottom</code>、<code>right</code>属性进行移动，并且，当A为<code>relative</code>的盒子时，其临近的盒子在渲染时会认为A并没有偏移。</li><li><code>absolute</code>、<code>fixed</code>：<code>absolute</code>的元素的<code>top</code>、<code>left</code>、<code>bottom</code>、<code>right</code>属性是相对于含有<code>position</code>属性的祖先元素的，也就是说<code>absolute</code>元素渲染出的盒子的位置不仅和<code>top/left/bottom/right</code>有关，还和最近的含有<code>position</code>属性的祖先元素的位置有关。<code>fixed</code>可以说是<code>absolute</code>的子类，两者都会是使盒子脱离普通流。<code>fixed</code>元素的定位和<code>absolute</code>差不多，只不过<code>fixed</code>的盒子参照的不再是含有<code>position</code>属性的祖先元素，而是一些固定的参照，比如视口（viewport），此时，盒子不会因为鼠标的滚动而滚动。<code>absolute</code>定位下的盒子不会发生外边距合并。</li></ul><h4 id="BFC和IFC"><a href="#BFC和IFC" class="headerlink" title="BFC和IFC"></a>BFC和IFC</h4><h5 id="BFC-Block-Formatting-Context"><a href="#BFC-Block-Formatting-Context" class="headerlink" title="BFC: Block Formatting Context"></a>BFC: Block Formatting Context</h5><p>什么情况下会产生新的BFC：</p><ul><li>float不为none</li><li>position不为static、relative</li><li>display为inline-block、table-cell、table-caption</li><li>overflow不为visible</li></ul><p>在__以上条件下的容器都会为自己的内容创建一个新的BFC__。</p><p>在BFC中，盒子都是从容器的顶部开始，从上至下一个接一个的垂直排列。两个盒子之间的垂直距离由margin属性来决定。在同一个BFC中，相邻的块级盒子之间的margin会发生折叠。</p><p>BFC更多的布局规则如下：</p><ul><li>每个元素的左边，与容器的左边相接触，即使浮动也是如此（如果是右布局的话则靠近右边缘）；</li><li>创建了BFC的元素不会与float元素重叠；</li><li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之也是如此；</li><li>计算BFC的高度时，浮动元素也参与其中。</li></ul><h6 id="BFC应用"><a href="#BFC应用" class="headerlink" title="BFC应用"></a>BFC应用</h6><p>比如，我们想实现一个简单的两栏布局，如下图所示：</p><p><img src="/images/20170212.png" alt="Alt text"></p><p>通常我们都是这么实现的</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css"><span class="selector-class">.black</span>&#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">width</span>:<span class="number">200px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">height</span>:<span class="number">200px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">float</span><span class="selector-pseudo">:left</span>;</span></span><br><span class="line"><span class="css"><span class="attribute">background</span>:black;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-class">.red</span>&#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">width</span>:<span class="number">200px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">height</span>:<span class="number">300px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">margin-left</span>:<span class="number">200px</span>;</span></span><br><span class="line"><span class="css"><span class="attribute">background</span>:red;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;black&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;red&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样确实也能实现如图的效果，但这种实现利用了左浮动的盒子的宽度和<code>margin-left</code>。如何使代码适用于更普遍的情况？答案就是使用<code>overflow:hidden</code>为右边的盒子重新创建一个BFC。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css"><span class="selector-class">.black</span>&#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">width</span>:<span class="number">200px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">height</span>:<span class="number">200px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">float</span><span class="selector-pseudo">:left</span>;</span></span><br><span class="line"><span class="css"><span class="attribute">background</span>:black;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-class">.red</span>&#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">width</span>:<span class="number">200px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">height</span>:<span class="number">300px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">overflow</span>:hidden;</span></span><br><span class="line"><span class="css"><span class="attribute">background</span>:red;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;black&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;red&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面的代码渲染出来的效果和上图一致，而且不需要知道左边盒子的宽度。利用到的就是BFC的布局规则之一：BFC的区域不会与float重叠。</p><p>BFC还可以用来解决外边距合并问题。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css"><span class="selector-class">.top</span>&#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">width</span>:<span class="number">100px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">height</span>:<span class="number">100px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">background</span>:red;</span></span><br><span class="line"><span class="css">      <span class="attribute">margin</span>:<span class="number">20px</span>;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-class">.bottom</span>&#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">width</span>:<span class="number">100px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">height</span>:<span class="number">100px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">background</span>:black;</span></span><br><span class="line"><span class="css">      <span class="attribute">margin</span>:<span class="number">20px</span>;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;top&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;bottom&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面代码显示的效果如下：</p><p><img src="/images/201702121700.png" alt="Alt text"></p><p>可以看到，上下两个盒子之间的边距只有20px，而不是想象中的40px，这就是因为发生了外边距合并（外边距合并只发生在垂直方向，水平方向不会有外边距合并），解决方法是使两个div 处于不同的BFC中，为其中一个元素添加具有BFC的包裹容器。修改代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css"><span class="selector-class">.top</span>&#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">width</span>:<span class="number">100px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">height</span>:<span class="number">100px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">background</span>:red;</span></span><br><span class="line"><span class="css">      <span class="attribute">margin</span>:<span class="number">20px</span>;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-class">.bottom</span>&#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">width</span>:<span class="number">100px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">height</span>:<span class="number">100px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">background</span>:black;</span></span><br><span class="line"><span class="css">      <span class="attribute">margin</span>:<span class="number">20px</span>;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-class">.box</span>&#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">overflow</span>:hidden;</span></span><br><span class="line"><span class="css">&#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;top&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;bottom&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>显示效果如下：</p><p><img src="/images/201702121712.png" alt="Alt text"></p><p>BFC清除浮动。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">.parent&#123;</span><br><span class="line">      width: 500px;</span><br><span class="line">      border:1ps solid black;</span><br><span class="line">&#125;</span><br><span class="line">.black&#123;</span><br><span class="line">margin-top:10px;</span><br><span class="line">      width:200px;</span><br><span class="line">      height:300px;</span><br><span class="line">      float:left;</span><br><span class="line">background:black;</span><br><span class="line">&#125;</span><br><span class="line">.red&#123;</span><br><span class="line">margin-top:10px;</span><br><span class="line">      width:200px;</span><br><span class="line">      height:300px;</span><br><span class="line">      float:left;</span><br><span class="line">background:red;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;div class=&quot;balck&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;red&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>由于子元素为浮动元素，处在另一个BFC中，所以父元素也就无法被撑开（BFC之间相互不影响），解决方法就是为父元素加上<code>overflow:hidden</code>(计算BFC的高度时，浮动元素也参与其中)。显示效果如下：</p><p><img src="/images/201901100958.png" alt="父元素无法被撑开"> <img src="/images/201702121736.png" alt="父元素被撑开"></p><h5 id="IFC-Inline-Formatting-Context"><a href="#IFC-Inline-Formatting-Context" class="headerlink" title="IFC: Inline Formatting Context"></a>IFC: Inline Formatting Context</h5><p>IFC由不包含块级盒子的容器创建。</p><p>在IFC中，盒子都是从包含容器头部开始，水平的一个接一个的排列的。水平方向的margin、border、padding控制着两盒子之间的距离。<br>处于同一行的盒子构成一个矩形区域，叫line box。</p><p>line box的宽度由浮动情况和它的容器决定。line box高度的计算规则可以看<a href="https://www.w3.org/TR/CSS22/visudet.html#line-height">这里</a></p><p>对于所包含的所有盒子来说，line box总是足够高的，也许它比包含在内部的最高的盒子还要高。对于盒子B来讲，如果B比包含它的line box高度低，那么B在line box中的垂直对齐方式可以通过vertical align属性控制。如果几个行内级盒子在一个单独的line box中不能完全放置下，它们就会被分配成2个或更多的垂直相邻的line boxes。因此，可以说，一个段落是多个line boxes的垂直排布构成的。除非特意添加间距，否则在垂直方向上，line boxes之间是没有距离的。</p><p>通常，line box的左边缘紧挨着它的容器的左边缘，右边缘紧挨着它的包含快的右边缘。然而浮动盒子也许会出现在容器边缘和line box边缘之间。因此，处于同一个行内格式上下文的line boxes通常都有相同的宽度（就是它的容器的宽度），但如果有浮动元素出现的话，它们的宽度会变得复杂，因为浮动元素会占据一定的容器宽度。line boxes在同样的行内格式上下文中，通常在高度上是多样的，（比如一行也许包含了一个最高的图片，而其他的可能只含有文字）。</p><p>当在一行中的行内级盒子的总宽度比包含他们的line box的宽度小，则他们在line box的水平位置由<code>text-align</code>属性决定。如果属性值是<code>justify</code>，则文字内容为两端对齐，大概下面这样的效果：</p><p><img src="/images/201901092009.png" alt="两端对齐"></p><p>代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">        </span></span><br><span class="line"><span class="css">    <span class="selector-class">.text</span> <span class="selector-tag">span</span>&#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">text-align</span>: justify;</span></span><br><span class="line"><span class="css">        <span class="attribute">display</span>: inline-block;</span></span><br><span class="line"><span class="css">        <span class="attribute">vertical-align</span>: top;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.text</span> <span class="selector-tag">span</span>:after&#123;</span></span><br><span class="line"><span class="css">        content:<span class="string">&#x27;&#x27;</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">display</span>: inline-block;</span></span><br><span class="line"><span class="css">        <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">        <span class="attribute">height</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">input</span>&#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css">        </span></span><br><span class="line"><span class="css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;text&quot;</span> &gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>电话<span class="tag">&lt;/<span class="name">span</span>&gt;</span>：<span class="tag">&lt;<span class="name">input</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>手机<span class="tag">&lt;/<span class="name">span</span>&gt;</span>：<span class="tag">&lt;<span class="name">input</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>电子邮箱<span class="tag">&lt;/<span class="name">span</span>&gt;</span>：<span class="tag">&lt;<span class="name">input</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>多说一点：</p><p><code>text-align:justify</code>不处理块内的最后一行文本，所以上面的代码中，给每个span之后又加了一个伪元素，使span内的文字不是最后一行。</p><p>参考：</p><p><a href="http://blog.sina.com.cn/s/blog_877284510101jo5d.html">http://blog.sina.com.cn/s/blog_877284510101jo5d.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;前提&quot;&gt;&lt;a href=&quot;#前提&quot; class=&quot;headerlink&quot; title=&quot;前提&quot;&gt;&lt;/a&gt;前提&lt;/h4&gt;&lt;p&gt;处于__普通流（Normal Flow）__中的盒子都会属于一个格式化上下文（Formatting context），要么是__块级格式化上</summary>
      
    
    
    
    
    <category term="BFC IFC CSS 布局 外边距折叠 定位策略" scheme="http://mengfansheng.com/tags/BFC-IFC-CSS-%E5%B8%83%E5%B1%80-%E5%A4%96%E8%BE%B9%E8%B7%9D%E6%8A%98%E5%8F%A0-%E5%AE%9A%E4%BD%8D%E7%AD%96%E7%95%A5/"/>
    
  </entry>
  
  <entry>
    <title>React为什么需要redux</title>
    <link href="http://mengfansheng.com/2018/12/25/React%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81redux/"/>
    <id>http://mengfansheng.com/2018/12/25/React%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81redux/</id>
    <published>2018-12-25T13:49:30.000Z</published>
    <updated>2020-03-29T03:47:40.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="React为什么需要redux？"><a href="#React为什么需要redux？" class="headerlink" title="React为什么需要redux？"></a>React为什么需要redux？</h4><p>1.React有props和state。props是父级分发下来的属性，state意味着组件内部可以自行管理的状态，__整个React应用的数据只能单向向下分发或者自行内部消化__，React没有数据向上回溯的能力。</p><p>2.在React内，使两个独立的组件沟通的方法往往是提升state，将state放到共有的父组件中来管理，再作为props分发给子组件。</p><p>3.子组件改变父组件state的方法一般是通过事件触发父组件声明好的回调，这样就出现了一个模式：数据总是单向从顶层向下分发的，只有子组件回调在概念上可以回到state顶层影响数据。</p><p>4.为了一步到位，干脆把所有state集中放到所有的组件顶层，然后分发给所有组件。</p><p>5.为了有更好的state管理，就需要一个工具作为更专业的顶层state分发给所有React应用，这就是Redux。</p><p>Redux是如何实现上面的需求的：</p><ul><li>需要回调通知state （相当于父级回调方法里的参数）-&gt; action</li><li>需要根据回调处理（等同于父级回调方法） -&gt; reducer</li><li>需要state -&gt; store</li></ul><p>对于Redux来说重点是action、reducer、store：</p><ul><li>action是一个纯声明式的数据结构（原生的js对象），只提供事件的所有要素，不提供逻辑。action描述了发生了什么事情和所发生事情的相关数据，但是针对发生的事情，程序该采取什么动作，action并不负责和关心。</li><li>reducer是一个匹配函数，action的发送是全局的：所有reducer都可以捕捉到并匹配是否与自己相关，相关就拿走action中的数据进行逻辑处理，修改store中的状态，不相关就不对state做处理并原样返回。</li><li>store负责存储状态，并可以被react api回调，发布action</li></ul><p>react-redux：将React和Redux联系起来：</p><ul><li>Provider是一个最顶层的组件，负责向下方传递state。它通过将store放在上下文中，所有被connect的组件都可以从上下文中获取到store。</li><li>connect，最复杂的部分：connect是一个组件，它从__上下文__中获取到store，进而得到state，然后通过mapStateToProps、mapStateToDispatch将state处理后以props的形式传递给它所包括的组件。<ul><li>mapStateToProps(state, ownProps, …)：通过对state处理，分拣出组件需要的Redux状态，最后返回一个对象，这个对象会以props的形式传给组件。</li><li>mapDispatchToProps(dispatch, ownProps, …)：返回一个对象，将声明好的回调作为props注入到组件里。如果没有这个参数，react-redux会将dispatch作为props传入组件中，在组件内可以直接调用dispatch(action)来表明一个动作的发生。</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;React为什么需要redux？&quot;&gt;&lt;a href=&quot;#React为什么需要redux？&quot; class=&quot;headerlink&quot; title=&quot;React为什么需要redux？&quot;&gt;&lt;/a&gt;React为什么需要redux？&lt;/h4&gt;&lt;p&gt;1.React有props和</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>React里的浅比较</title>
    <link href="http://mengfansheng.com/2018/12/23/React%E9%87%8C%E7%9A%84%E6%B5%85%E6%AF%94%E8%BE%83/"/>
    <id>http://mengfansheng.com/2018/12/23/React%E9%87%8C%E7%9A%84%E6%B5%85%E6%AF%94%E8%BE%83/</id>
    <published>2018-12-23T14:02:36.000Z</published>
    <updated>2020-03-29T03:47:42.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="React里的浅比较"><a href="#React里的浅比较" class="headerlink" title="React里的浅比较"></a>React里的浅比较</h4><p>​    react的PureComponent类的shouldComponentUpdate方法使用了浅比较来判断props和state是否发生变化，一些组件可以通过继承PureComponent来优化组件性能，减少不必要的re-render。但是有些组件即使继承了PureComponent也没有任何性能上的改变。我们来看看浅比较的原理。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hasOwnProperty = <span class="built_in">Object</span>.prototype.hasOwnProperty;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">is</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x === y) &#123;</span><br><span class="line">    <span class="keyword">return</span> x !== <span class="number">0</span> || y !== <span class="number">0</span> || <span class="number">1</span> / x === <span class="number">1</span> / y;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x !== x &amp;&amp; y !== y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//....</span></span><br></pre></td></tr></table></figure><p>​    以上是react中浅比较的部分源码。<code>is</code>方法是es6中<code>Object.is</code>方法的实现，我理解主要是为了兼容低版本浏览器。</p><p>​    <code>Object.is()</code>方法能很好的对基本类型的数据进行比较，并且不会出现<code>==</code>时的类型转换，也不会产生<code>NaN!==NaN</code>为true的以及<code>-0 == +0</code>的情况。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.is(<span class="literal">null</span>, <span class="literal">undefined</span>);<span class="comment">//false</span></span><br><span class="line"><span class="built_in">Object</span>.is(<span class="literal">NaN</span>, <span class="literal">NaN</span>);<span class="comment">//true</span></span><br><span class="line"><span class="built_in">Object</span>.is(-<span class="number">0</span>, +<span class="number">0</span>);<span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>​    当比较的两个值满足下列情况时，<code>Object.is()</code>方法返回true：</p><ul><li>都是<code>undefined</code></li><li>都是<code>null</code></li><li>都是<code>true</code>或者<code>false</code></li><li>都是由相同字符组成的相同长度的字符串</li><li>指向的都是同一个对象</li><li>都是数字，并且<ul><li>都是+0</li><li>都是-0</li><li>都是非0且非NaN的相同值的数字</li></ul></li></ul><p>以上情况在比较的时候就会返回true。可以看出，<code>Object.is()</code>方法弥补了<code>==</code>和<code>===</code>比较的缺陷。</p><p>下面逐步解读一下<code>shallowEqual</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hasOwnProperty = <span class="built_in">Object</span>.prototype.hasOwnProperty;</span><br><span class="line"><span class="comment">//声明is方法，兼容老浏览器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">is</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x === y) &#123;</span><br><span class="line">    <span class="comment">//如果 x 严格等于 y，这里面有一种情况是需要特别注意的，就是-0===+0也是true</span></span><br><span class="line">    <span class="comment">//所以额外判断下两个参数是否有等于0的情况，-0 ！== 0 返回false</span></span><br><span class="line">    <span class="keyword">return</span> x !== <span class="number">0</span> || y !== <span class="number">0</span> || <span class="number">1</span> / x === <span class="number">1</span> / y;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果两者不严格相等，也有中情况是需要额外处理的，就是NaN ===  NaN是返回false的</span></span><br><span class="line">    <span class="comment">// 所以特殊处理下，如果x严格不等于自己，y也严格不等于自己，则说明两者是NaN，这时候就要返回true</span></span><br><span class="line">    <span class="keyword">return</span> x !== x &amp;&amp; y !== y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shallowEqual</span>(<span class="params">objA: mixed, objB: mixed</span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">  <span class="comment">//判断objA和objB是否相等，相等直接返回true</span></span><br><span class="line">  <span class="keyword">if</span> (is(objA, objB)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  如果不相等，那么就要看下两参数是否是对象（Object.is只能对基本类型数据做比较精准的比较）。</span></span><br><span class="line"><span class="comment">  浅比较需要进入到对象的第一层，不能仅引用不一样就直接返回false。</span></span><br><span class="line"><span class="comment">  此外，如果两者有一个参数为null，那也不用继续下去了，两者已经不相等了，并且有一个为null，则</span></span><br><span class="line"><span class="comment">  表示肯定有变化发生了，shallowEqual可以直接返回false</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    <span class="keyword">typeof</span> objA !== <span class="string">&#x27;object&#x27;</span> ||</span><br><span class="line">    objA === <span class="literal">null</span> ||</span><br><span class="line">    <span class="keyword">typeof</span> objB !== <span class="string">&#x27;object&#x27;</span> ||</span><br><span class="line">    objB === <span class="literal">null</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//如果是对象，同时两者又没有null，则开始进入到对象的第一层来比较</span></span><br><span class="line">  <span class="comment">//获取两个对象的key值组成数组</span></span><br><span class="line">  <span class="keyword">const</span> keysA = <span class="built_in">Object</span>.keys(objA);</span><br><span class="line">  <span class="keyword">const</span> keysB = <span class="built_in">Object</span>.keys(objB);</span><br><span class="line">  <span class="comment">//如果属性长度都不一样，则表示两者不相等，返回false</span></span><br><span class="line">  <span class="keyword">if</span> (keysA.length !== keysB.length) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//接下来一个属性一个属性的比较</span></span><br><span class="line">  <span class="comment">//如果objA的属性objB没有，或者两者同一个属性的值不相等，则表示objA和objB不相等，返回false</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keysA.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      !hasOwnProperty.call(objB, keysA[i]) ||</span><br><span class="line">      !is(objA[keysA[i]], objB[keysA[i]])</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    通过上面的代码的可以看出（尤其最后一段），当传入参数是对象时__浅比较只会进入到对象的第一层__，如果参数对象的属性值仍然是对象，这时候是不会递归进入到属性值内部去比较的；如果参数对象前后指向的是不同的引用，即使引用所指向对象的内部属性值都是一样，shallowEqual返回的结果仍会是false。如果想此时仍能使用PureComponent达到性能优化的结果，则必须保证传入参数所指向的都是同一个引用。</p><p>​    综上，PureComponent有性能优化的功能，前提是组件接收的props或者组件内部的state结构比较简单。如果props或者state嵌套比较深（有两层及以上的嵌套），则可能就没法通过shallowEqual比较出变化，这也是有些组件使用了PureComponent后没有发现有任何性能上的优化的原因。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;React里的浅比较&quot;&gt;&lt;a href=&quot;#React里的浅比较&quot; class=&quot;headerlink&quot; title=&quot;React里的浅比较&quot;&gt;&lt;/a&gt;React里的浅比较&lt;/h4&gt;&lt;p&gt;​    react的PureComponent类的shouldCompon</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>构建自己的React:Didact fiber</title>
    <link href="http://mengfansheng.com/2018/12/12/%E6%9E%84%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84React-Didact-fiber/"/>
    <id>http://mengfansheng.com/2018/12/12/%E6%9E%84%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84React-Didact-fiber/</id>
    <published>2018-12-12T02:26:01.000Z</published>
    <updated>2020-03-29T03:47:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>翻译自这里：<a href="https://engineering.hexacta.com/didact-fiber-incremental-reconciliation-b2fe028dcaec">https://engineering.hexacta.com/didact-fiber-incremental-reconciliation-b2fe028dcaec</a></p><p>React16已经发布了，其内部重写了很多代码，内部结构也发生了一些变化，有一些新的特性也随之推出。我们在之前系列里写的代码多多少少有些过时了。在这一节，我们将会根据React16的最新结构来重写大部分的代码，代码结构和变量命名我们也会尽量按照React16的来。我们的代码暴露了一下几个API：</p><ul><li><code>Didact.createElement</code></li><li><code>Didact.render()</code>（用来DOM渲染）</li><li><code>Didact.Component</code>(带有<code>setState()</code>，但没有<code>context</code>及其他生命周期方法)</li></ul><p>以上API不需要的东西我们不会涉及。</p><p>如果你想直接看代码及运行效果，可以看<a href="https://codepen.io/pomber/pen/veVOdd">这里</a>，或者访问<a href="https://github.com/pomber/didact">代码库</a>。</p><p>好了，先来解释下以前的代码为什么需要重写。</p><h4 id="Why-Fiber"><a href="#Why-Fiber" class="headerlink" title="Why Fiber"></a>Why Fiber</h4><blockquote><p>我们不会解释的很详细，如果你想具体了解，可以看一下这个<a href="https://github.com/koba04/react-fiber-resources">list</a></p></blockquote><p>当浏览器的主线程一直被某一任务占用时，其他任务就无法去执行，直到占用主线程的任务完成，其他任务才有可能被执行。</p><p>我做了一个<a href="https://pomber.github.io/incremental-rendering-demo/react-sync.html">demo</a>来展示上面提到的问题。为了保持星球的持续转动，主线程至少每隔16ms就需要空闲出来以渲染页面。假如主线程一直被其他任务占用，比如占用了200ms，你就会发现动画有一些丢帧（通俗的说就是卡顿），在主线程被占用时星球会停着不动。</p><p>那么是什么一直占用着主线程，使得主线程无法去执行渲染任务以至于页面有卡顿呢？</p><p>还记得我们写的<a href="https://engineering.hexacta.com/didact-instances-reconciliation-and-virtual-dom-9316d650f1d0">一致性校验的代码</a>么？一旦开始一致性校验，过程就不会停止。此时，如果其他任务需要执行，那么只有排队等待。而且，因为一致性校验是一个递归的规程，所以很难暂停。接下来我们将会使用一种新的数据结构来重写一致性校验的代码，并用循环来代替递归。</p><h4 id="Scheduling-micro-tasks"><a href="#Scheduling-micro-tasks" class="headerlink" title="Scheduling micro-tasks"></a>Scheduling micro-tasks</h4><p>我们需要把__任务__分割成更细小的__任务片__，以单位任务片的方式来执行这些任务，在执行的间隙，主线程可以去执行有更高优先级的其他任务，结束之后再回来继续执行剩余的任务片。</p><p>我们将定义一个<code>requestIdleCallback()</code>方法来完成上述功能。这个方法会维护一个回调，这个回调是下次浏览器空闲时需要去执行的任务。在执行这个回调时还会传入一个<code>deadline</code>参数，用来描述当前有多少时间可以用来执行这个任务。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ENOUGH_TIME = <span class="number">1</span>; <span class="comment">// 毫秒</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> workQueue = [];</span><br><span class="line"><span class="keyword">let</span> nextUnitOfWork = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">schedule</span>(<span class="params">task</span>)</span>&#123;</span><br><span class="line">    workQueue.push(task);</span><br><span class="line">    requestIdleCallback(performWork);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">performWork</span>(<span class="params">deadline</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!nextUnitOfWork)&#123;</span><br><span class="line">       nextUnitOfWork = workQueue.shift();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(nextUnitOfWork &amp;&amp; deadline.timeRemaining() &gt; ENOUGH_TIME )&#123;</span><br><span class="line">        nextUnitOfWork = performUnitOfWork(nextUnitOfWork);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(nextUnitOfWork || workQueue.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        requestIdleCallback(performWork);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>真正执行任务的是<code>performUnitOfWork</code>这个方法，我们的一致性校验算法也需要写到这个方法里面。这个方法会执行任务片并返回下次需要执行的任务片。</p><p>我们使用fiber来跟踪任务片的执行。</p><h4 id="The-fiber-data-structure"><a href="#The-fiber-data-structure" class="headerlink" title="The fiber data structure"></a>The fiber data structure</h4><p>每个组件（__注意，这里的组件不仅是用户定义的组件，也代表浏览器原生的HTML标签__）我们都会为其创建一个fiber。<code>nextUnitOfWork</code>指向的是下一次我们要运行的fiber。<code>performUnitOfWork</code>会执行当前的fiber并在执行结束后返回一个新的fiber。跟紧我，接下来我将详细解释一下。</p><p>先来看下fiber的结构：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fiber = &#123;</span><br><span class="line">    <span class="attr">tag</span>: HOST_COMPONENT,</span><br><span class="line">   <span class="attr">type</span>: <span class="string">&#x27;div&#x27;</span>,</span><br><span class="line">    <span class="attr">parent</span>: parentFiber,</span><br><span class="line">    <span class="attr">child</span>: childFiber,</span><br><span class="line">    <span class="attr">sibling</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">alternate</span>: currentFiber,</span><br><span class="line">    <span class="attr">stateNode</span>: <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>),</span><br><span class="line">    <span class="attr">props</span>: &#123;<span class="attr">children</span>: [], <span class="attr">className</span>: <span class="string">&#x27;foo&#x27;</span>&#125;,</span><br><span class="line">    <span class="attr">partialState</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">effectTag</span>: PLACEMENT,</span><br><span class="line">   <span class="attr">effects</span>: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看起来只是一个很普通的JS对象。</p><p><code>parent</code>，<code>child</code>以及<code>sibling</code>将被用来构建一颗描述组件的fiber树。<code>stateNode</code>指向一个DOM元素或者是用户定义的组件的实例。</p><p><img src="/images/201812031109.png" alt="变量说明"></p><p>上面的图片展示了我们需要支持的三种类型的组件：</p><ul><li><code>b</code>，<code>p</code>及<code>i</code>这一类的fiber我们称为__host components__，用<code>tag:HOST_COMPONENT</code>来表示。这一类fiber的<code>type</code>属性值为一个字符串（即对应的html元素标签名）。<code>props</code>则放置着对应元素的属性和事件。</li><li><code>Foo</code>对应的fiber我们称为__class components__，对应的<code>tag</code>标签值为<code>CLASS_COMPONENT</code>。这一类fiber的<code>type</code>属性值为指向用户定义的组件类的引用。</li><li><code>div</code>对应的fiber我们称为__host root__。host root和host component都含有一个DOM元素作为<code>stateNode</code>的属性值，但host root作为fiber树的根，将会受到一些特别的对待。我们使用<code>tag:HOST_ROOT</code>来区分host root。注意到，此类fiber的<code>stateNode</code>对应的DOM节点将会被传入到<code>Didact.render()</code>中。</li></ul><p>另一个比较重要的属性是<code>alternate</code>。__大多数情况下我们代码中存在两棵fiber树：一颗对应着已经渲染到页面的DOM，我们称之为current tree或者old tree；另一颗为我们更新（调用<code>setState()</code>或者<code>Didact.render()</code>）过程中构建的树，我们称之为work-in-progress tree。__（这两棵树的节点都是一个个fiber）</p><p>work-in-progress tree不会和old tree共享fiber。一旦work-in-progress tree构建结束，对应的DOM都被渲染完毕，work-in-progress tree就会变成old tree。</p><p><code>alternate</code>用来连接work-in-progress tree上的fiber对应的old tree上的fiber。一个fiber与它的<code>alternate</code>指向的old tree上的fiber拥有相同的<code>tag</code>，<code>type</code>和<code>stateNode</code>。当我们在渲染一个新的结构时，对应的fiber不会含有<code>alternate</code>属性。</p><p>接下来是<code>effects</code>数组和<code>effectTag</code>。当work-in-progress tree上的某一个fiber需要对DOM做一些变更时，我们会给这个fiber设置<code>effecttTag</code>属性，取值有三种：<code>PLACEMENT</code>，<code>UPDATE</code>，或者<code>DELETION</code>。为了更方便的实施DOM的变更，我们将当前fiber下含有<code>effectTag</code>的子fiber都保存在<code>effects</code>数组中。</p><p>上面说了比较多的概念，一时理解有些困难，如果跟不上也不要担心，下面我们在实际代码中来了解一下fiber。</p><h4 id="Didact-call-hierarchy"><a href="#Didact-call-hierarchy" class="headerlink" title="Didact call hierarchy"></a>Didact call hierarchy</h4><p>我们通过流程图来感知一下即将要写的代码的调用层次：</p><p><img src="/images/201812038046.png" alt="fiber流程"></p><p>我们会从<code>render()</code>或者<code>setState()</code>开始，到<code>commitAllWork()</code>结束。</p><h4 id="Old-code"><a href="#Old-code" class="headerlink" title="Old code"></a>Old code</h4><p>在开始重写之前先来回顾下以前写的代码。</p><p>在<a href="https://engineering.hexacta.com/didact-element-creation-and-jsx-d05171c55c56">Element creation and JSX</a>中我们编写了<a href="https://gist.github.com/pomber/2bf987785b1dea8c48baff04e453b07f"><code>crerateElement()</code></a>方法用来转译JSX。这个方法不需要改动，元素的结构也没有发生变化。如果你不知道我们所说的元素，<code>type</code>，<code>props</code>和<code>children</code>是什么，那么你需要回顾一下之前的内容。</p><p>在<a href="https://engineering.hexacta.com/didact-instances-reconciliation-and-virtual-dom-9316d650f1d0">Instances, reconciliation and virtual DOM</a>这一节我们写了<code>updateDomProperties()</code>方法用来更新DOM节点的属性。我们还写了<code>createDomElement()</code>方法用来创建DOM节点。这两个方法你都可以在<a href="https://gist.github.com/pomber/c63bd22dbfa6c4af86ba2cae0a863064">dom-utils.js</a>中看到。</p><p>在<a href="https://engineering.hexacta.com/didact-components-and-state-53ab4c900e37">Components and state</a>这一节我们编写了<code>Component</code>基础类。这个类需要一些改动。<code>setState()</code>方法中需要去调用<code>scheduleUpdate()</code>方法。此外还要创建一个<code>createInstance</code>方法来代替之前的<code>createPublicInstance()</code>方法，<code>createInstance</code>创建的实例保存了自身对应的fiber的引用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.props = props || &#123;&#125;;</span><br><span class="line">        <span class="built_in">this</span>.state = <span class="built_in">this</span>.state || &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="title">setState</span>(<span class="params">partialState</span>)</span>&#123;</span><br><span class="line">        scheduleUpdate(<span class="built_in">this</span>, partialState);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createInstance</span>(<span class="params">fiber</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> instance = <span class="keyword">new</span> fiber.type(fiber.props);</span><br><span class="line">    instance.__fiber = fiber;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们就从上面这段代码开始，重写剩下的功能。</p><p><img src="/images/201812032124.png" alt="render()&amp;scheduleUpdate()"></p><p>除了<code>Component</code>类和<code>createElement()</code>方法外，我们还有两个暴露出来的方法：<code>render()</code>和<code>setState()</code>，并且我们知道我们将在<code>setState()</code>中调用<code>scheduleUpdate()</code>。</p><p><code>render()</code>方法和<code>scheduleUpdate()</code>方法有些类似，它们都会接收一个更新（本文提到的更新既包括页面的初次渲染，也包括字面意义上的更新）任务，然后放到队列中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fiber分类标签</span></span><br><span class="line"><span class="keyword">const</span> HOST_COMPONENT = <span class="string">&#x27;host&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> CLASS_COMPONENT = <span class="string">&#x27;class&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> HOST_ROOT = <span class="string">&#x27;root&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量</span></span><br><span class="line"><span class="keyword">const</span> updateQueue = [];</span><br><span class="line"><span class="keyword">let</span> nextUnitOfWork = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> pendingCommit = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">elements, containerDom</span>)</span>&#123;</span><br><span class="line">    updateQueue.push(&#123;</span><br><span class="line">        <span class="attr">from</span>: HOST_ROOT,</span><br><span class="line">        <span class="attr">dom</span>: containerDom,</span><br><span class="line">        <span class="attr">newProps</span>: &#123;<span class="attr">children</span>: elements&#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    requestIdleCallback(performWork);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scheduleUpdate</span>(<span class="params">instance, partialState</span>)</span>&#123;</span><br><span class="line">    updateQueue.push(&#123;</span><br><span class="line">        <span class="attr">from</span>: CLASS_COMPONENT,</span><br><span class="line">        <span class="attr">instance</span>: instance,</span><br><span class="line">        <span class="attr">partialState</span>: partialState</span><br><span class="line">    &#125;);</span><br><span class="line">    requestIdleCallback(performWork); <span class="comment">// 延迟调用performWork</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>updateQueue</code>数组用来盛装要实施的更新，每次调用<code>render()</code>或者<code>scheduleUpdate()</code>方法都会往<code>updateQueue</code>中增加一个更新操作。每个更新操作携带的信息都不相同，我们将会在接下来的<code>resetNextUnitOfWork()</code>方法中看到如何去实施这些更新。</p><p>在把更新放到队列中之后，我们对<code>performWork()</code>做了一个延迟调用（意思是在浏览器空闲的时候调用）。</p><p><img src="/images/201812040958.png" alt="performWork()&amp;workLoop()"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ENOUGH_TIME = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">performWork</span>(<span class="params">deadline</span>)</span>&#123;</span><br><span class="line">    workLoop(deadline);</span><br><span class="line">    <span class="keyword">if</span>(nextUnitOfWork || updateQueue.length &gt; )&#123;</span><br><span class="line">        requestIdleCallback(performWork);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">workLoop</span>(<span class="params">deadline</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!nextUnitOfWork)&#123;</span><br><span class="line">        resetNextUnitOfWork(); <span class="comment">// 产生第一个nextUnitOfWork</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(nextUnitOfWork &amp;&amp; deadline.timeRemaining() &gt; ENOUGH_TIME)&#123;</span><br><span class="line">        nextUnitOfWork = performUnitOfWork(nextUnitOfWork);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pendingCommit)&#123;</span><br><span class="line">        commitAllWork(pendingCommit);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>requestIdleCallback()</code>方法会将一个deadline传入目标方法（就是<code>performWork()</code>）中，并执行这个方法。<code>performWork()</code>会将接收到的deadline传递给<code>workLoop()</code>方法，<code>workLoop()</code>执行结束后，<code>performWork()</code>中剩下的代码还会检查是否还有等待完成的任务，如果有，则会在浏览器空闲的时候再次调用自己。</p><p><code>workLoop()</code>会监视着deadline参数，如果deadline太短，方法内部会自动停止循环，并保持nextUnitOfWork不做改变，下次会继续执行这个任务。</p><blockquote><p> ENOUGH_TIME是一个代表1ms的常量，通过<code>deadline.timeRemaining()</code>与ENOUGH_TIME的比较来判断是否有足够的时间来执行当前这个任务。如果<code>performUnitOfWork()</code>所需要的时间超过ENOUGH_TIME，我们会适当增加deadline的值。deadline只是浏览器所建议的一个时间，所以增加几毫秒时没有什么问题的。</p><p> （We use <code>ENOUGH_TIME</code> (a 1ms constant, same as <a href="https://github.com/facebook/react/blob/b52a5624e95f77166ffa520476d68231640692f9/packages/react-reconciler/src/ReactFiberScheduler.js#L154">React’s</a>) to check if <code>deadline.timeRemaining()</code> is enough to run another unit of work or not. If <code>performUnitOfWork()</code> takes more than that, we will overrun the deadline. The deadline is just a suggestion from the browser, so overrunning it for a few milliseconds is not that bad.—-这一段说实话我不太明白什么意思）</p></blockquote><p><code>performUnitOfWork()</code>会为当前的更新操作构建一颗work-in-progress tree，并会比较出需要对DOM实施的变更。这些操作都是逐步进行的，每次构建一个fiber节点。</p><p>当<code>performUnitOfWork()</code>结束了当前更新所需要做的任务之后，会返回null（这样循环就结束了）并将要实施的更新操作保存在<code>pendingCommit</code>变量中。最后，<code>commitAllWork()</code>会从<code>pendingCommit</code>中取出<code>effects</code>，并对对应的DOM实施变更操作。</p><p>注意到<code>commitAllWork()</code>是在循环外面调用的。<code>performUnitOfWork()</code>的任务完成后并没有对DOM进行变更（只是记录），所以它是可以分开执行的，而<code>commitAllWork()</code>是会对DOM进行改变的，所以为了保证代码和UI显示一致，需要一次性将<code>commitAllWork()</code>执行完毕。</p><p>说了这么多，我们依然不知道第一个<code>nextUnitOfWork</code>来自于哪里。</p><p><img src="/images/201812042140.png" alt="resetUnitOfWork()"></p><p><code>resetUnitOfWork()</code>方法会接收一个更新操作并将其转化为<code>nextUnitOfWork</code>（其实就是根fiber）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resetNextUnitOfWork</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> update = updateQueue.shift();</span><br><span class="line">    <span class="keyword">if</span>(!update)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将更新操作中携带的state复制给对应fiber</span></span><br><span class="line">    <span class="keyword">if</span>(update.partialState)&#123; <span class="comment">// 通过setState()更新才会有partialState</span></span><br><span class="line">        update.instance.__fiber.partialState = update.partialState;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> root = update.from == HOST_ROOT</span><br><span class="line">    ? update.dom.__rootContainerFiber</span><br><span class="line">    : getRoot(update.instance.__fiber);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注意看，这时候的fiber都是没有child属性的，返回的是根节点的fiber。</span></span><br><span class="line">    <span class="comment">// 就是old tree的根节点</span></span><br><span class="line">    nextUnitOfWork = &#123;</span><br><span class="line">        <span class="attr">tag</span>: HOST_ROOT,</span><br><span class="line">        <span class="comment">// 如果是render()引起的话，stateNode从update.dom取值，否则从root.stateNode取值</span></span><br><span class="line">        <span class="attr">stateNode</span>: update.dom || root.stateNode,</span><br><span class="line">        <span class="comment">// props同理</span></span><br><span class="line">        <span class="attr">props</span>: update.newProps || root.props;</span><br><span class="line">        alternate: root</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRoot</span>(<span class="params">fiber</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> node = fiber;</span><br><span class="line">    <span class="keyword">while</span>(node.parent)&#123;</span><br><span class="line">        node = node.parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，<code>resetNextUnitOfWork()</code>会从<code>updateQueue</code>头部取出一个更新操作，如果这个更新操作携带有<code>partialState</code>信息，那么将该信息复制到此次更新对应组件实例的fiber上，在稍后调用组件的<code>render()</code>方法时会用到这个<code>partialState</code>。</p><p>接下来是寻找old fiber tree的根节点。如果此次更新是整个应用第一次调用<code>render()</code>（第一次渲染）引起的，则不存在根fiber节点，所以<code>root = null</code>；如果此次更新是由非第一次调用<code>render()</code>方法引起的，我们则可以通过DOM节点的<code>__rootContainerFiber</code>属性找到根fiber节点；如果此次更新是由<code>setState()</code>引起的，则需要从当前fiber往上查找，直到找到没有<code>parent</code>属性那个fiber节点，即为根fiber节点。</p><p>找完根fiber节点后，我们给<code>nextUnitOfWork</code>赋值一个新的fiber。__这个fiber是一棵新work-in-progress tree的根fiber节点__（因为是本次渲染的第一个<code>nextUnitOfWork</code>，所以是根fiber节点）。</p><p>如果不存在old root（说明这是初次渲染），则<code>stateNode</code>就是传入<code>render()</code>方法的那个DOM节点，<code>props</code>是来自于此次渲染的<code>newProps</code>，<code>newProps</code>的<code>children</code>数组含有的其他元素也会被传入到<code>render()</code>方法中。<code>alternate</code>属性将会是<code>null</code>（因为是初次渲染，不存在old tree）。</p><p>如果存在old root（真正意义上的更新操作，增量渲染），则<code>stateNode</code>就是上一次渲染的根DOM节点，<code>props</code>同样会从<code>newProps</code>取值，如果<code>newProps</code>为<code>null</code>的话，则从old root上取值。<code>alternate</code>指向的就是old root。</p><p>现在已经有了work-in-progress tree个根fiber节点，接下来我们从这个根节点开始构建work-in-progress fiber tree。</p><p><img src="/images/201812051509.png" alt="performUnitOfWork"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">performUnitOfWork</span>(<span class="params">wipFiber</span>)</span>&#123;</span><br><span class="line">    beginWork(wipFiber);</span><br><span class="line">    <span class="keyword">if</span>(wipFiber.child)&#123;</span><br><span class="line">        <span class="keyword">return</span> wipFiber.child;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果没有子元素，则寻找兄弟元素</span></span><br><span class="line">    <span class="keyword">let</span> uow = wipFiber;</span><br><span class="line">    <span class="keyword">while</span>(uow)&#123;</span><br><span class="line">        completeWork(uow); <span class="comment">// 如果wipFiber没有子元素，或者当所有子节点都被处理完毕时会被调用</span></span><br><span class="line">        <span class="keyword">if</span>(uow.sibling)&#123;</span><br><span class="line">            <span class="keyword">return</span> uow.sibling； <span class="comment">// 返回找到的兄弟元素，构建一个节点。</span></span><br><span class="line">        &#125;</span><br><span class="line">        uow = uow.parent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>performUnitOfWork()</code>方法会贯穿于整棵fiber树的构建过程。</p><p><code>beginWork()</code>用来为传入的fiber创建子fiber节点，然后将第一个子fiber节点返回作为下一个<code>nextUnitOfWork</code>参数。</p><p>如果当前已有fiber不存在子节点，则执行<code>completeWork()</code>方法，然后返回其兄弟节点作为下一个<code>nextUnitOfWork</code>参数。</p><p>如果当前fiber连兄弟节点也不存在，则向上查找，并逐层调用<code>completeWork</code>方法，直到找到并返回兄弟节点或者到达根节点。</p><p>fiber树的创建过程中，<code>performUnitOfWork()</code>会被调用多次。</p><p>我们会以深度优先的原则去创建一棵fiber树。从根节点开始，遍历每个节点的第一个子fiber（即child属性所指向的对象）。当到达某一个fiber节点时，我们会将该节点作为入参去调用<code>performUnitOfWork()</code>；如果某一fiber节点不含有子节点，则往右移动找寻兄弟节点，如果不存在兄弟节点则往上寻找祖先元素的兄弟节点，如此进行直到找到兄弟节点并将其带入到<code>performUnitOfWork()</code>中执行或者到达根节点。然后以当前节点为起点，继续按照深度优先的原则去遍历和创建fiber节点，整个过程会调用<code>performUnitOfWork()</code>多次，直到整棵树创建完毕。（可以在这里<a href="https://fiber-debugger.surge.sh/">fiber-debugger</a>查看更生动的描述）</p><p><img src="/images/201812052125.png" alt="beginWork&amp;updateHostComponent&amp;updateClassComponent"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">beginWork</span>(<span class="params">wipFiber</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(wipFiber.tag == CLASS_COMPONENT)&#123;</span><br><span class="line">        updateClassComponent(wipFiber)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        updateHostComponent(wipFiber)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateHostComponent</span>(<span class="params">wipFiber</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!wipFiber.stateNode)&#123;</span><br><span class="line">        wipFiber.stateNode = createDomElement(wipFiber);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> newChildElements = wipFiber.props.children;</span><br><span class="line">    reconcileChildrenArray(wipFiber, newChildElements);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateClassComponent</span>(<span class="params">wipFiber</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> instance = wipFiber.stateNode;</span><br><span class="line">    <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="comment">// 调用构造函数，创建实例</span></span><br><span class="line">        instance = wipFiber.stateNode = createInstance(wipFiber)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(wipFiber.props == instance.props &amp;&amp; !wipFiber.partialState)&#123;</span><br><span class="line">        cloneChildFiber(wipFiber);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    instance.props = wipFiber.props;</span><br><span class="line">    instance.state = <span class="built_in">Object</span>.assign(&#123;&#125;, instance.state, wipFiber.partialState);</span><br><span class="line">    wipFiber.partialState = <span class="literal">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> newChildElements = wipFiber.stateNode.render();</span><br><span class="line">    reconcileChildrenArray(wipFiber, newChildElements);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>beginWork()</code>做了两件事：</p><ul><li>如果传入的fiber没有<code>stateNode</code>节点的话为其创建一个。</li><li>获取组件的子元素，并将它们传入<code>reconcileChildrenArray()</code>中。</li></ul><p>因为要考虑不同的组件类型，所以干脆就分成了两个方法来处理：<code>updateHostComponent()</code>和<code>updateClassComponent()</code>。</p><p><code>updateHostComponent()</code>方法用来处理host components及root component两种类型组件。如果传入的fiber不含有<code>stateNode</code>，则方法会为其创建一个（只有一个节点且不含有子元素，更不会添加到页面上），然后方法会从fiber的<code>props</code>属性中取出<code>children</code>并传入<code>reconcileChildrenArray()</code>中去执行性。</p><p>传入<code>updateClassComponent()</code>方法的fiber如果没有实例的话，则方法内部首先会通过调用组件的构建函数为其创建一个实例。创建出来的实例会被添加最新的 <code>props</code>和<code>state</code>属性，之后调用实例的<code>render()</code>方法来获取最新的子元素。如果传入进来的fiber有对应的实例，则说明不是一个新的节点。这时候如果fiber的props和实例的props相等，并且fiber上不带有<code>partialState</code>属性，则说明节点前后没有发生变化（相当于一个简易版的<code>shouldComponentUpdate()</code>），不需要重新渲染，直接克隆该节点到work-in-progress tree就可以了。</p><p>现在我们有了子元素<code>newChildElements</code>，可以继续向下构建work-in-progress fiber tree了。</p><p><img src="/images/201812062154.png" alt="reconcileChildrenArray()"></p><p><code>reconcileChildrenArray()</code>是一个比较核心的代码，fiber树的构建以及要对DOM实施的变化都会在这个方法里面完成。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PLACEMENT = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> DELETION = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> UPDATE = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">arrify</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> val == <span class="literal">null</span> ? <span class="literal">null</span> : <span class="built_in">Array</span>.isArray(val) ? val : [val];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reconcileChildArray</span>(<span class="params">wipFiber, newChildElements</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> elements = arrify(newChildElements);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> oldFiber = wipFiber.alternate ? wipFiber.alternate.child : <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> newFiber = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(index &lt; elements.length || oldFiber != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">const</span> prevFiber = newFiber;</span><br><span class="line">        <span class="keyword">const</span> element = index &lt; elements.length &amp;&amp; elements[index];</span><br><span class="line">        <span class="keyword">const</span> sameType = oldFiber &amp;&amp; element &amp;&amp; element.type == oldFiber.type;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(sameType)&#123; <span class="comment">// 如果前后fiber类型一样，说明是一个更新操作</span></span><br><span class="line">            newFiber = &#123;</span><br><span class="line">                <span class="attr">type</span>: oldFiber.type,</span><br><span class="line">                <span class="attr">tag</span>: oldFiber.tag,</span><br><span class="line">                <span class="attr">stateNode</span>: oldFiber.stateNode,</span><br><span class="line">                <span class="attr">props</span>: element.props,</span><br><span class="line">                <span class="attr">parent</span>: wipFiber,</span><br><span class="line">                <span class="attr">alternate</span>: oldFiber,</span><br><span class="line">                <span class="attr">partialState</span>: oldFiber.partialState,</span><br><span class="line">                <span class="attr">effectTag</span>: UPDATE</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(element &amp;&amp; !sameType)&#123;</span><br><span class="line">            newFiber = &#123;</span><br><span class="line">                <span class="attr">type</span>: element.type,</span><br><span class="line">                <span class="attr">tag</span>: </span><br><span class="line">                <span class="keyword">typeof</span> element.type === <span class="string">&#x27;string&#x27;</span> ?HOST_COMPPONENT: CLASS_COMPONENT,</span><br><span class="line">                <span class="attr">props</span>: element.props,</span><br><span class="line">                <span class="attr">parent</span>: wipFiber,</span><br><span class="line">                <span class="attr">effectTag</span>: PLACEMENT</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(oldFiber &amp;&amp; !sameType)&#123;</span><br><span class="line">            oldFiber.effectTag = DELETION;</span><br><span class="line">            wipFiber.effects = wipFiber.effects || [];</span><br><span class="line">            wipFiber.effects.push(oldFiber); <span class="comment">// 记录oldFiber的删除操作</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(oldFiber)&#123;</span><br><span class="line">            oldFiber = oldFiber.sibling;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(index == <span class="number">0</span>)&#123;</span><br><span class="line">            wipFiber.child = newFiber; <span class="comment">// fiber的child属性指向的是第一个子fiber</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(prevFiber &amp;&amp; element)&#123;</span><br><span class="line">            prevFiber.sibling = newFiber; <span class="comment">// 剩下的子fiber相互之间通过sibling属性关联</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>一开始我们要确保传入的<code>newChildElements</code>是个数组。（这和我们之前写的一致性校验的算法有些不同，之前的<code>render()</code>方法返回的是一个对象，不支持数组，现在这个是子元素全部放在数组中，也就是说我们可以在组件的<code>render()</code>方法中直接返回一个数组了）。</p><p>接下来将<code>wipFiber.alernate</code>（即old fiber tree）的子节点与<code>wipFiber.props.children</code>对应的元素或者执行<code>wipFiber.stateNode.render()</code>后返回的元素进行比较。（fiber节点与元素进行比较，这地方的元素就是用对象表示的JSX）</p><p>在比较时，是<code>oldFiber</code>-<code>element</code>成对的比较。先是第一个fiber子节点（<code>oldFiber = wipFiber.alternate.child</code>）与第一个子元素（<code>elements[0]</code>）比较，比较结束后，<code>oldFiber</code>赋值为其自身的兄弟节点（<code>oldFiber = oldFiber.sibling</code>），然后继续与第二个子元素比较（<code>elements[1]</code>）。比较结束后再次执行<code>oldFiber = oldFiber.sibling</code>，然后再将<code>oldFiber</code>与<code>elements[2]</code>比较。以此方式比较下去：</p><ul><li>如果<code>oldFiber</code>和对应的<code>element</code>有相同的<code>type</code>，则代表<code>oldFiber.stateNode</code>可以被重用，我们会基于<code>oldFiber</code>来创建一个新的fiber，并将新fiber的<code>effectTag</code>属性设置为<code>UPDATE</code>，然后将这个新的fiber添加到work-in-progress tree上。</li><li>如果<code>element</code>与对应的<code>oldFiber</code>的<code>type</code>属性值不一样，或者说当前的<code>element</code>没有对应的<code>oldFiber</code>（新增元素的情况），我们会根据<code>element</code>上含有的信息新建一个fiber。注意，这个新建的fiber没有<code>alternate</code>属性，也没有<code>stateNode</code>属性（<code>stateNode</code>属性会在<code>beginWork()</code>中被创建）。我们会将这个新建fiber的<code>effectTag</code>设置为<code>PLACEMENT</code>。</li><li>如果<code>element</code>与对应的<code>oldFiber</code>的<code>type</code>属性值不一样，或者<code>oldFiber</code>没有对应的<code>element</code>（说明有元素需要被删除），我们会将<code>oldFiber</code>的<code>effectTag</code>设置为<code>DELETION</code>。由于<code>oldFiber</code>并不是work-in-progress tree的一部，我们需要将其添加到<code>wipFiber.effects</code>列表中以防止丢失。</li></ul><p><em>我们并没有像React那样使用key属性来做一致性校验，如果子元素只是换了一个位置的话，我们的代码并不会做特殊处理。</em></p><p><img src="/images/201812071640.png" alt="cloneChildFibers()"></p><p><code>updateClassComponent()</code>方法中考虑了一种特殊的情况，当某个节点不需要更新时，可以直接将对应old filber tree上的节点拷贝到work-in-progress tree上，省去了一致性校验的过程。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneChildFibers</span>(<span class="params">parentFiber</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> oldFiber = parentFiber.alternate; <span class="comment">// 获取传入的fiber对应的oldFiber</span></span><br><span class="line">    <span class="keyword">if</span>(!oldFiber.child)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> oldChild = oldFiber.child;</span><br><span class="line">    <span class="keyword">let</span> prevChild = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(oldChild)&#123; <span class="comment">// 循环拷贝子元素</span></span><br><span class="line">        <span class="keyword">const</span> newChild = &#123;</span><br><span class="line">            <span class="attr">type</span>: oldChild.type,</span><br><span class="line">            <span class="attr">tag</span>: oldChild.tag,</span><br><span class="line">            <span class="attr">stateNode</span>: oldChild.stateNode,</span><br><span class="line">            <span class="attr">props</span>: oldChild.props,</span><br><span class="line">            <span class="attr">partialState</span>: oldChild.partialState,</span><br><span class="line">            <span class="attr">alternate</span>: oldChild,</span><br><span class="line">            <span class="attr">parent</span>: parentFiber</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">if</span>(prevChild)&#123;</span><br><span class="line">            prevChild.sibling = newChild;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            parentFiber.child = newChild;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        prevChild = newChild;</span><br><span class="line">        oldChild = oldChild.sibling; <span class="comment">//  通过sibling（兄弟）关系循环所有子元素</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>cloneChildFibers()</code>会克隆传入的<code>wipFiber.alternate</code>指向的fiber的所有子元素，并将它们添加到work-in-progress tree上。因为确定这些节点没有发生什么变化，所以并不需要添加<code>effectTag</code>属性。</p><p><img src="/images/201812081525.png" alt="completeWork()"></p><p>在<code>performUnitOfWork()</code>中，当<code>wipFiber</code>没有子元素或者当所有子元素都被执行完毕后，我们就会调用<code>completeWork()</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">completeWork</span>(<span class="params">fiber</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fiber.tag == CLASS_COMPONENT)&#123; <span class="comment">// 如果是一个类组件</span></span><br><span class="line">        fiber.stateNode.__fiber = fiber;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 每次更新都要重新构建一整颗fiber树</span></span><br><span class="line">    <span class="keyword">if</span>(fiber.parent)&#123;</span><br><span class="line">        <span class="keyword">const</span> childEffects = fiber.effects || [];</span><br><span class="line">        <span class="keyword">const</span> thisEffect = fiber.effectTag != <span class="literal">null</span> ? [fiber] : [];</span><br><span class="line">        <span class="keyword">const</span> parentEffects = fiber.parent.effects || [];</span><br><span class="line">        fiber.parent.effects = parentEffects.concat(childEffects, thisEffect);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pendingCommit = fiber;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>completeWork()</code>首先更新传入的fiber对应实例类组件对象的fiber引用（可能不一定非要在这个地方，但代码里需要这么几行代码）。</p><p>接下来，方法内部会构建一个<code>effcts</code>列表，这个列表会将work-in-progres sub-tree上含有<code>effectTag</code>属性的fiber都包含在内（old sub-tree上含有<code>DELETION effectTag</code>的fiber也会被包含在这个effects列表中）。通过这样的<code>effects</code>列表，根fiber的<code>efffects</code>会包含所有带有<code>effectTag</code>的fiber。</p><p>最后，当fiber不含有<code>parent</code>属性时，说明我们已经到达了work-in-progress tree的根部，此时，我们已经完成了此次的更新操作所需要的工作，并收集了所有的effects。接下来，我们将根节点赋值给<code>pendingCommit</code>，然后<code>workLoop()</code>会去调用<code>commmitAllWork()</code>来完成更新。</p><p><img src="/images/201812081608.png" alt="commitAllWork&amp;commitWork"></p><p>接下来就剩一件事了，将更新实施到DOM上。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitAllWork</span>(<span class="params">fiber</span>)</span>&#123;</span><br><span class="line">    fiber.effects.forEach(<span class="function"><span class="params">f</span> =&gt;</span> &#123;</span><br><span class="line">        commitWork(f);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 根fiber节点对应的DOM节点有个__rootContainerFiber属性引用着根fiber</span></span><br><span class="line">    fiber.stateNode.__rootContainerFiber = fiber;</span><br><span class="line">    nextUnitOfWork = <span class="literal">null</span>;</span><br><span class="line">    pendingCommit = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitWork</span>(<span class="params">fiber</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fiber.tag == HOST_ROOT)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> domParentFiber = fiber.parent;</span><br><span class="line">    <span class="comment">// 寻找一个dom类型的祖先fiber(stateNode属性对应为原生DOM)</span></span><br><span class="line">    <span class="keyword">while</span>(domParentFiber.tag == CLASS_COMPONENT)&#123;</span><br><span class="line">        domParentFiber = domParentFiber.parent;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 有了DOM才好去调用DOM的那些方法去操作DOM</span></span><br><span class="line">    <span class="keyword">const</span> domParent = domParentFiber.stateNode;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(fiber.effectTag == PLACEMENT &amp;&amp; fiber.tag = HOST_COMPONENT)&#123; <span class="comment">// 添加一个DOM</span></span><br><span class="line">        domParent.appendChild(fiber.stateNode);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(fiber.effectTag == UPDATE)&#123; <span class="comment">// 更新一个DOM</span></span><br><span class="line">        updateDomProperties(fiber.stateNode, fiber.alternate.props, fiber.props);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(fiber.effectTag == DELETION)&#123;</span><br><span class="line">        commitDeletion(fiber, domParent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitDeletion</span>(<span class="params">fiber, domParent</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> node =fiber;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(node.tag == CLASS_COMPONENT)&#123;</span><br><span class="line">            node = node.child;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        domParent.removeChild(node.stateNode);</span><br><span class="line">        <span class="comment">// 如果node不等于fiber，并且没有兄弟节点，说明已经删除完毕</span></span><br><span class="line">        <span class="keyword">while</span>(node != fiber &amp;&amp; !node.sibling)&#123;</span><br><span class="line">            node = node.parent; <span class="comment">// 删除完毕后node重置为刚开始的值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node == fiber)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        node = node.sibling;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>commitAllWork()</code>会循环根fiber上的<code>effects</code>数组，针对每个元素都会去调用<code>commitWork()</code>方法。<code>commitWork</code>会检查每个fiber的<code>effectTag</code>属性：</p><ul><li><code>effectTag:PLACEMENT</code>：先找到父DOM节点，然后直接将fiber的<code>stateNode</code>属性对应的DOM节点直接append到父DOM节点下。</li><li><code>effectTag:UPDATE</code>：将<code>stateNode</code>及其对应的新旧props传入<code>updateDomProperties</code>中，方法内部再去对节点进行更新。</li><li><code>effectTag:DELETION</code>：如果当前的fiber是一个host component（<code>stateNode</code>属性为一个原生DOM节点），这种时候直接通过其父节点调用<code>removeChild()</code>方法来删除该节点；如果当前的fiber是一个class component，在进行删除之前，需要找到组件对应的sub fiber-tree上所有的host component，然后再进行删除。</li></ul><p>当前的effects都被实施后，需要重置<code>nextUnitOfWork</code>和<code>pendingCommit</code>，work-in-progress tree也变成了old tree，所以我们会将它的根节点设置到其对应DOM节点的<code>__rootContainerFiber</code>属性上。这些都做完后，当前的更新就都完成了，我们可以进行下一个了。</p><h4 id="Running-Didact"><a href="#Running-Didact" class="headerlink" title="Running Didact"></a>Running Didact</h4><p>把上面我们写的代码加入到Didact中，然后暴露公共API即可：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">importDidact</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">// All the code we wrote</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        createElement,</span><br><span class="line">        render,</span><br><span class="line">        Component</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**<span class="doctag">@jsx </span>Didact.createElement*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloMessage</span> <span class="keyword">extends</span> <span class="title">Didact</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello &#123;this.props.name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Didact.render(</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">HelloMessage</span> <span class="attr">name</span>=<span class="string">&#x27;John&#x27;</span> &gt;</span>,</span></span><br><span class="line"><span class="xml">document.getElementById(&#x27;container&#x27;)</span></span><br><span class="line"><span class="xml">)</span></span><br></pre></td></tr></table></figure><h4 id="What’s-next"><a href="#What’s-next" class="headerlink" title="What’s next?"></a>What’s next?</h4><p>React的很多特性Didact都没有，其中我比较感兴趣的就是根据优先级来调度更新：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">NoWork</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">SynchronousPriority</span>:  <span class="number">1</span>, <span class="comment">// For controlled text inputs.Synchronous side-effects.</span></span><br><span class="line">    <span class="attr">TaskPriority</span>: <span class="number">2</span>,<span class="comment">// Completes at the end of the current tick</span></span><br><span class="line">    <span class="attr">HighPriority</span>: <span class="number">3</span>,<span class="comment">//Interaction that needs to complete preety soon to feel responsive</span></span><br><span class="line">    <span class="attr">LowPriority</span>: <span class="number">4</span>, <span class="comment">//Data fetching, or result from updating stores</span></span><br><span class="line">    <span class="attr">OffscreenPriority</span>: <span class="number">5</span> <span class="comment">//Won&#x27;t be  visible but do the work in case it becomes visible</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以如果有下一节的话可能就会涉及到上面的内容。</p><p>以上就是全部内容了。如果你喜欢，别忘了点赞，或者<a href="https://twitter.com/pomber">推特上关注我</a>。</p><p>记得留下你的评论。</p><p>感谢阅读，喜欢的记得点击star。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;翻译自这里：&lt;a href=&quot;https://engineering.hexacta.com/didact-fiber-incremental-reconciliation-b2fe028dcaec&quot;&gt;https://engineering.hexacta.com/dida</summary>
      
    
    
    
    
  </entry>
  
</feed>
