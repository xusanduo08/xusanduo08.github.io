<!DOCTYPE html><html lang="中文"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> webpack是如何加载模块的（三）：react是如何实现路由级动态加载的 · Neo</title><meta name="description" content="webpack是如何加载模块的（三）：react是如何实现路由级动态加载的 - 孟凡胜"><meta name="viewport" content="width=device-width, initial-scale=1"><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="HandheldFriendly" content="True"><meta name="MobileOptimized" content="320"><meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0, maximum-scale=1, user-scalable=no, minimal-ui"><meta name="keywords" content="react redux redux-saga"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="apple-touch-icon" href="2048/meta/apple-touch-icon.png"><link rel="apple-touch-startup-image" href="2048/meta/apple-touch-startup-image-640x1096.png" media="(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2)"><link rel="apple-touch-startup-image" href="2048/meta/apple-touch-startup-image-640x920.png" media="(device-width: 320px) and (device-height: 480px) and (-webkit-device-pixel-ratio: 2)"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-146300475-1"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date())

gtag('config', 'UA-146300475-1')
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?cfd774e7572f024fbb235d52afbd4103";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script><link rel="search" type="application/opensearchdescription+xml" href="http://mengfansheng.com/atom.xml" title="Neo"><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Neo" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://segmentfault.com/a/1190000017234428" target="_blank" class="nav-list-link">SEGMENGFAULT</a></li><li class="nav-list-item"><a href="https://github.com/xusanduo08" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/2048/" target="_self" class="nav-list-link">GAMES</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">webpack是如何加载模块的（三）：react是如何实现路由级动态加载的</h1><div class="post-info">Dec 10, 2021</div><div class="post-content"><p>以下内容所使用的webpack版本是4.43。</p>
<p>react实现动态加载官方目前给出的方案有两种，一种是使用<code>import()</code>语法，配合loadable-component这个第三方库使用；一种是使用<code>React.lazy()</code>。<code>React.lazy()</code>目前不支持服务端渲染，如果想在服务端做动态加载只能使用<code>import()</code>+loadable-component方法。</p>
<p>实现动态加载首先要做的就是确定哪些代码需要动态加载，也就是代码的分割界限如何设定。分割的一个标准就是要确保分割后的代码在动态加载时不能影响到用户体验。</p>
<p><strong>路由级动态加载</strong>就是根据路由来进行代码分割。应用中的代码是按照路由进行分割的，路由不同的页面在打包时会被打包到不同文件中，当访问某个具体路由时，当前路由对应的页面就会被动态加载进来。根据路由来进行代码分割的好处就是用户一般感知不到代码加载过程。因为用户一般习惯于在页面切换的间隙有一定的等待时间，如果在这个等待时间加载代码的话，那么代码加载对用户体验的影响会比较小。而且由于在切换页面时用户默认允许一个等待时间，在等待时也不会对元素进行操作，也就避免了一些异常情况的出现。</p>
<p>下面看下loadable-component实现路由级动态加载的逻辑。</p>
<p>通过前面两篇文章的讲解，我们知道，<code>import(chunkId)</code>语法在编译后实际变成了下面这个样子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__webpack_require_.e(chunkId).then(__webpack_require.bind(chunkPath))</span><br></pre></td></tr></table></figure>

<p><code>__webpack_require.e()</code>：动态加载代码</p>
<p><code>__webpack_require.bind(chunkPath)</code>：运行模块代码，并返回模块导出的内容</p>
<p>以上这些将在下面讲解的时候用到。</p>
<p>App.js</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> loadable <span class="keyword">from</span> <span class="string">&#x27;./loadable/component/src&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  BrowserRouter <span class="keyword">as</span> Router,</span><br><span class="line">  Route,</span><br><span class="line">  Link</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Async = loadable(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./Async&#x27;</span>), &#123;<span class="attr">fallback</span>: <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>loading...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>&#125;);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [showAsync, setShowAsync] = useState(<span class="literal">false</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Router</span>&gt;</span></span></span><br><span class="line"><span class="xml">    App</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&#x27;/async&#x27;</span>&gt;</span>Async<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;/async&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Async</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">Router</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure>

<p>Async.js</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Async</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Async<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Async;</span><br></pre></td></tr></table></figure>

<p>上面组件的业务很简单：当访问<code>/async</code>路由时先去<strong>远程加载</strong><code>Async</code>组件代码然后再<strong>渲染</strong>。</p>
<p><code>&lt;Route /&gt;</code>路由组件的作用是当访问这个路由时再渲染对应的页面/组件，动态加载的功能并不是<code>&lt;Route /&gt;</code>实现的。对于要动态加载的组件，需要通过<code>loadable()</code>方法处理下，<code>loadable()</code>其实是一个具有动态加载内部组件功能的HOC，为了方便后面的叙述，把经过loadable处理过的组件加个HOC-前缀。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HOCAsync = loadable(</span><br><span class="line">  <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./Async&#x27;</span>), </span><br><span class="line">  &#123;<span class="attr">fallback</span>: <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>loading...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>&#125; <span class="comment">// 加载时显示的loading状态</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">/*******************/</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;/async&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">HOCAsync</span> /&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>当访问<code>/async</code>路由时，<code>HOCAsync</code>会先被渲染，其内部检测到真正的Async组件代码还没有加载的话就会先去加载，加载结束后再渲染。</p>
<p>接着来看下<code>loadable()</code>方法是如何实现动态加载的。</p>
<p>文章开头就说了，<code>import(chunkId)</code>在经过编译后变成下面的样子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__webpack_require_.e(chunkId).then(__webpack_require.bind(chunkPath))</span><br></pre></td></tr></table></figure>

<p>那么<code>()=&gt;import(&#39;./Async&#39;)</code>编译后的结果其实就是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">()=&gt; __webpack_require_.e(chunkId).then(__webpack_require.bind(chunkPath))</span><br></pre></td></tr></table></figure>

<p>说白了就是一个返回模块导出内容的函数。</p>
<p><code>loadable()</code>内部的实现逻辑其实也比较简单，在<code>componentDidMount()</code>中触发执行上面的代码加载逻辑：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.mounted = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.state.loading) &#123;</span><br><span class="line">    <span class="built_in">this</span>.loadAsync() <span class="comment">// 加载代码</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">this</span>.state.error) &#123;</span><br><span class="line">    <span class="built_in">this</span>.triggerOnLoad()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加载完毕就能获取到组件内容，然后渲染：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">loadAsync</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">this</span>.promise) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; __chunkExtractor, forwardedRef, ...props &#125; = <span class="built_in">this</span>.props</span><br><span class="line">    <span class="comment">// ctor.requireAsync就是() =&gt; import(&#x27;./Async.js&#x27;)方法</span></span><br><span class="line">    <span class="built_in">this</span>.promise = ctor</span><br><span class="line">      .requireAsync(props) <span class="comment">// 这地方为什么要传props:为了支持full dynamic imports</span></span><br><span class="line">      .then(<span class="function"><span class="params">loadedModule</span> =&gt;</span> &#123; <span class="comment">// loadedModule就是模块导出的内容</span></span><br><span class="line">      <span class="keyword">const</span> result = resolve(loadedModule, &#123; Loadable &#125;) <span class="comment">// 加载到的组件存储在result变量中</span></span><br><span class="line">      <span class="keyword">if</span> (options.suspense) &#123;</span><br><span class="line">        <span class="built_in">this</span>.setCache(result)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">    &#125;)</span><br><span class="line">      .catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.safeSetState(&#123; error, <span class="attr">loading</span>: <span class="literal">false</span> &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.promise</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>loadAsync()</code>方法将获取到的模块内容放到<code>result</code>变量中，接下来在<code>render()</code>方法中渲染<code>result</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="comment">// 在未成功加载前，先渲染传入进来的loading组件</span></span><br><span class="line">  <span class="keyword">const</span> fallback = propFallback || options.fallback || <span class="literal">null</span></span><br><span class="line">  <span class="keyword">if</span> (loading) &#123;</span><br><span class="line">    <span class="keyword">return</span> fallback</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> render(&#123;</span><br><span class="line">    loading,</span><br><span class="line">    fallback,</span><br><span class="line">    result,</span><br><span class="line">    options,</span><br><span class="line">    <span class="attr">props</span>: &#123; ...props, <span class="attr">ref</span>: forwardedRef &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>loadable()</code>方法对组件做了一定的性能优化。在使用时，可以传入cacheKey，用来作为组件是否发生改变的标志，如果没有传入cacheKey，则默认使用<code>JSON.stringfy(props)</code>的返回值作为cacheKey，每次外层HOC更新完毕后会比较前后两次cacheKey是否发生改变，如有改变，则重新调用<code>this.loadAsync()</code>方法计算最新的组件内容然后再渲染：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCacheKey</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (options.cacheKey) &#123;</span><br><span class="line">    <span class="keyword">return</span> options.cacheKey(props) <span class="comment">// 计算缓存key</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (ctor.resolve) &#123;</span><br><span class="line">    <span class="keyword">return</span> ctor.resolve(props)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">  <span class="built_in">super</span>(props)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.state = &#123;</span><br><span class="line">    <span class="attr">result</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">error</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">loading</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">cacheKey</span>: getCacheKey(props), <span class="comment">// 设置缓存key：cacheKey</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ....</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">componentDidUpdate</span>(<span class="params">prevProps, prevState</span>)</span> &#123;</span><br><span class="line">  <span class="comment">// 如果cacheKey有变化，则重新获取组件内容然后重新渲染</span></span><br><span class="line">  <span class="keyword">if</span> (prevState.cacheKey !== <span class="built_in">this</span>.state.cacheKey) &#123;</span><br><span class="line">    <span class="built_in">this</span>.promise = <span class="literal">null</span></span><br><span class="line">    <span class="built_in">this</span>.loadAsync()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>总结：loadable是一个HOC，内部依然是使用的webpack的<code>__webpack_require_.e(chunkId)</code>方法动态加载的代码。在工作时，外层组件会先去远程加载组件内容，然后再渲染。可以设置cacheKey属性，增强组件性能。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2021/12/10/webpack%E6%98%AF%E5%A6%82%E4%BD%95%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9D%97%E7%9A%84%EF%BC%88%E4%BA%8C%EF%BC%89/" class="next">下一篇</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'seansun';
var disqus_identifier = '2021/12/10/webpack是如何加载模块的（三）/';
var disqus_title = 'webpack是如何加载模块的（三）：react是如何实现路由级动态加载的';
var disqus_url = 'http://mengfansheng.com/2021/12/10/webpack是如何加载模块的（三）/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//seansun.disqus.com/count.js" async></script><div class="copyright"><p>© 2015 - 2021 <a href="http://mengfansheng.com">孟凡胜</a>, <a href="http://www.beian.miit.gov.cn" target="_blank">苏ICP备17022623号</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>