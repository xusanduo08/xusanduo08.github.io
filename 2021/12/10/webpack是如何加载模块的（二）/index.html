<!DOCTYPE html><html lang="中文"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> webpack是如何加载模块的（二）：异步模块的加载 · Neo</title><meta name="description" content="webpack 异步加载 懒加载"><meta name="viewport" content="width=device-width, initial-scale=1"><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="HandheldFriendly" content="True"><meta name="MobileOptimized" content="320"><meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0, maximum-scale=1, user-scalable=no, minimal-ui"><meta name="keywords" content="react redux redux-saga"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="apple-touch-icon" href="2048/meta/apple-touch-icon.png"><link rel="apple-touch-startup-image" href="2048/meta/apple-touch-startup-image-640x1096.png" media="(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2)"><link rel="apple-touch-startup-image" href="2048/meta/apple-touch-startup-image-640x920.png" media="(device-width: 320px) and (device-height: 480px) and (-webkit-device-pixel-ratio: 2)"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-146300475-1"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date())

gtag('config', 'UA-146300475-1')
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?cfd774e7572f024fbb235d52afbd4103";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script><link rel="search" type="application/opensearchdescription+xml" href="http://mengfansheng.com/atom.xml" title="Neo"><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Neo" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://segmentfault.com/a/1190000017234428" target="_blank" class="nav-list-link">SEGMENGFAULT</a></li><li class="nav-list-item"><a href="https://github.com/xusanduo08" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/2048/" target="_self" class="nav-list-link">GAMES</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">webpack是如何加载模块的（二）：异步模块的加载</h1><div class="post-info">Dec 10, 2021</div><div class="post-content"><p>以下内容所使用的webpack版本是4.43。</p>
<p>webpack可以把项目代码打包成一个bundle.js，如果项目比较大的话，这个bundle.js体积也会比较大。如果用户打开首页上来就加载一个很大的文件的话，一定程度上会影响用户的体验。而且，这个bundle.js还包含了一些用户不常访问的页面，这不经常访问的页面没有必要打包进去（因为访问几率比较低），可以在访问时再去加载这个页面的代码。这样减少了初次加载的bundle.js的体积，可以提高初次访问时页面打开的速度。但是这种方式也增加了http请求次数，因为要去按需加载，同时还要加载一些控制按需加载的代码。所以，在使用webpack按需加载进行项目优化时，需要综合考虑。</p>
<p>有两种按需加载的实现方式，一种是使用正在处于ECMAScript提议阶段的import()语法；另一种是使用webpack自己的规范require.ensure。</p>
<blockquote>
<p>import()内部使用promise实现。因此在老的浏览器中使用的话要注意兼容。</p>
</blockquote>
<p>本文接下来研究的是通过<code>import()</code>方法加载异步模块的实现。</p>
<p>同样是两个文件：</p>
<p>index.js</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setInterval</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">window</span>.show)&#123;</span><br><span class="line">    <span class="keyword">import</span>(<span class="string">&#x27;./asyncc.js&#x27;</span>).then(<span class="function">(<span class="params">&#123;<span class="keyword">default</span>: text&#125;</span>) =&gt;</span> <span class="built_in">console</span>.log(text))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>

<p>async.js</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> text=<span class="string">&#x27;async&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> text;</span><br></pre></td></tr></table></figure>



<p>打包后获得两个文件，先忽略细节，看结构</p>
<p>index.bundle.js：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">modules</span>) </span>&#123; </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">webpackJsonpCallback</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 模块缓存</span></span><br><span class="line">  <span class="keyword">var</span> installedModules = &#123;&#125;;</span><br><span class="line">  <span class="comment">// 已加载（0）/待加载（undefined）/预加载（preloaded）/正在加载（promise）的模块</span></span><br><span class="line">  <span class="keyword">var</span> installedChunks = &#123;</span><br><span class="line">    <span class="string">&quot;index&quot;</span>: <span class="number">0</span></span><br><span class="line">  &#125;;</span><br><span class="line">   </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">jsonpScriptSrc</span>(<span class="params">chunkId</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="comment">// The require function</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">__webpack_require__</span>(<span class="params">moduleId</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  __webpack_require__.e = <span class="function"><span class="keyword">function</span> <span class="title">requireEnsure</span>(<span class="params">chunkId</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"> &#125;;</span><br><span class="line">  <span class="keyword">return</span> __webpack_require__(__webpack_require__.s = <span class="string">&quot;./src/index.js&quot;</span>);</span><br><span class="line"> &#125;)(&#123;</span><br><span class="line"> <span class="string">&quot;./src/index.js&quot;</span>:</span><br><span class="line">   (<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">module</span>, __webpack_exports__, __webpack_require__</span>) </span>&#123;</span><br><span class="line"><span class="meta">    &quot;use strict&quot;</span>;</span><br><span class="line">    __webpack_require__.r(__webpack_exports__);</span><br><span class="line">    <span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">window</span>.show) &#123;</span><br><span class="line">        __webpack_require__.e(<span class="comment">/*! import() */</span> <span class="number">0</span>).</span><br><span class="line">        then(__webpack_require__.bind(<span class="literal">null</span>, <span class="string">&quot;./src/asyncc.js&quot;</span>)).</span><br><span class="line">        then(<span class="function"><span class="keyword">function</span> (<span class="params">_ref</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">var</span> text = _ref[<span class="string">&quot;default&quot;</span>];</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">console</span>.log(text);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">    __webpack_exports__[<span class="string">&quot;default&quot;</span>] = (<span class="string">&#x27;ssss&#x27;</span>);</span><br><span class="line">   &#125;)</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure>

<p>0.bundle.js：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="built_in">window</span>[<span class="string">&quot;webpackJsonp&quot;</span>] = <span class="built_in">window</span>[<span class="string">&quot;webpackJsonp&quot;</span>] || []).push([[<span class="number">0</span>],&#123;</span><br><span class="line"><span class="string">&quot;./src/asyncc.js&quot;</span>:</span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">module</span>, __webpack_exports__, __webpack_require__</span>) </span>&#123;</span><br><span class="line"><span class="meta">    &quot;use strict&quot;</span>;</span><br><span class="line">    __webpack_require__.r(__webpack_exports__);</span><br><span class="line">    <span class="keyword">var</span> text = <span class="string">&#x27;async&#x27;</span>;</span><br><span class="line">    __webpack_exports__[<span class="string">&quot;default&quot;</span>] = (text);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;]);</span><br></pre></td></tr></table></figure>



<p>从整体看打包后文件结构和都是同步加载时的打包文件结构差不多：都是一个立即执行函数，函数入参同样也是一个以文件路径为key，文件内容为值的对象（姑且称之为<strong>模块对象</strong>）；同样使用了<code>__webpack_require__(moduleId)</code>加载同步代码；同样有模块缓存<code>installedModules</code>。</p>
<p>也有一些不同点，比如，相比都是同步加载，使用异步加载的代码打包后文件内容要多一些，有一些方法在同步加载时没有（比如webpackJsonpCallback，jsonpScriptSrc）；需要同步加载的所有文件都打包在了一块，但需要异步加载的文件单独打包了出来（0.bundle.js）；对模块的加载状态进行了记录<code>installedChunks</code>。</p>
<p>对于同步文件的加载依然是使用<code>__webpack_require__(moduleId)</code>来加载，具体解析可以看上一篇文章。下面看下index.js中是如何加载async.js的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> <span class="string">&quot;./src/index.js&quot;</span>:(<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">module</span>, __webpack_exports__, __webpack_require__</span>) </span>&#123;</span><br><span class="line"><span class="meta">    &quot;use strict&quot;</span>;</span><br><span class="line">    __webpack_require__.r(__webpack_exports__);</span><br><span class="line">    <span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">window</span>.show) &#123;</span><br><span class="line">        __webpack_require__.e(<span class="comment">/*! import() */</span> <span class="number">0</span>).</span><br><span class="line">        then(__webpack_require__.bind(<span class="literal">null</span>, <span class="string">&quot;./src/asyncc.js&quot;</span>)).</span><br><span class="line">        then(<span class="function"><span class="keyword">function</span> (<span class="params">_ref</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">var</span> text = _ref[<span class="string">&quot;default&quot;</span>];</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">console</span>.log(text);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">    __webpack_exports__[<span class="string">&quot;default&quot;</span>] = (<span class="string">&#x27;ssss&#x27;</span>);</span><br><span class="line">   &#125;)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>以上是index.js编译后得到的内容。对照源码可以看到原来的<code>import(&#39;./async&#39;)</code>被编译成了<code>__webpack__require__.e(0)</code>，<code>__webpack__require__.e</code>方法源码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">__webpack_require__.e = <span class="function"><span class="keyword">function</span> <span class="title">requireEnsure</span>(<span class="params">chunkId</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> promises = [];</span><br><span class="line">  <span class="keyword">var</span> installedChunkData = installedChunks[chunkId];</span><br><span class="line">  <span class="keyword">if</span>(installedChunkData !== <span class="number">0</span>) &#123; <span class="comment">// 0 表示已经加载过</span></span><br><span class="line">    <span class="comment">// 正在加载</span></span><br><span class="line">    <span class="keyword">if</span>(installedChunkData) &#123;</span><br><span class="line">      promises.push(installedChunkData[<span class="number">2</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 创建promise，并存放到缓存installedChunks中</span></span><br><span class="line">      <span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        installedChunkData = installedChunks[chunkId] = [resolve, reject];</span><br><span class="line">      &#125;);</span><br><span class="line">      promises.push(installedChunkData[<span class="number">2</span>] = promise);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 开始加载异步模块</span></span><br><span class="line">      <span class="comment">// 创建script标签</span></span><br><span class="line">      <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">      <span class="keyword">var</span> onScriptComplete;</span><br><span class="line">      <span class="comment">// 设置字符集</span></span><br><span class="line">      script.charset = <span class="string">&#x27;utf-8&#x27;</span>;</span><br><span class="line">      <span class="comment">// 设置超时时间</span></span><br><span class="line">      script.timeout = <span class="number">120</span>;</span><br><span class="line">      <span class="keyword">if</span> (__webpack_require__.nc) &#123;</span><br><span class="line">        script.setAttribute(<span class="string">&quot;nonce&quot;</span>, __webpack_require__.nc);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 设置src</span></span><br><span class="line">      script.src = jsonpScriptSrc(chunkId);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> error = <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">      <span class="comment">// 加载完成/超时/出错 事件响应方法</span></span><br><span class="line">      onScriptComplete = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 避免IE中出现内存泄漏</span></span><br><span class="line">        script.onerror = script.onload = <span class="literal">null</span>; </span><br><span class="line">        <span class="comment">// 清除定时器</span></span><br><span class="line">        <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">        <span class="keyword">var</span> chunk = installedChunks[chunkId];</span><br><span class="line">          <span class="keyword">if</span>(chunk !== <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(chunk) &#123;</span><br><span class="line">              <span class="comment">// 设置错误信息</span></span><br><span class="line">              <span class="keyword">var</span> errorType = event &amp;&amp; (event.type === <span class="string">&#x27;load&#x27;</span> ? <span class="string">&#x27;missing&#x27;</span> : event.type);</span><br><span class="line">              <span class="keyword">var</span> realSrc = event &amp;&amp; event.target &amp;&amp; event.target.src;</span><br><span class="line">              error.message = <span class="string">&#x27;Loading chunk &#x27;</span> + chunkId + <span class="string">&#x27; failed.\n(&#x27;</span> + errorType + <span class="string">&#x27;: &#x27;</span> + realSrc + <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">              error.name = <span class="string">&#x27;ChunkLoadError&#x27;</span>;</span><br><span class="line">              error.type = errorType;</span><br><span class="line">              error.request = realSrc;</span><br><span class="line">              chunk[<span class="number">1</span>](error);</span><br><span class="line">            &#125;</span><br><span class="line">            installedChunks[chunkId] = <span class="literal">undefined</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 定时器，超时后触发</span></span><br><span class="line">        <span class="keyword">var</span> timeout = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">          onScriptComplete(&#123; <span class="attr">type</span>: <span class="string">&#x27;timeout&#x27;</span>, <span class="attr">target</span>: script &#125;);</span><br><span class="line">        &#125;, <span class="number">120000</span>);</span><br><span class="line">        script.onerror = script.onload = onScriptComplete;</span><br><span class="line">        <span class="comment">// 将script标签添加到head内，开始加载脚本</span></span><br><span class="line">        <span class="built_in">document</span>.head.appendChild(script);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.all(promises);</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>

<p>上面一段代码看着东西挺多，但其实做的事情挺简单：</p>
<ol>
<li><p>检查要加载的代码是否已经加载过，加载过则直接返回，否则继续往下走；</p>
</li>
<li><p>创建一个代表即将要加载的代码的promise，并将这个promise存储到内存中供后面使用；</p>
</li>
<li><p>接着就是创建script标签，设置script的一些包括src在内的属性，然后将scirpt标签append到head内，浏览器就会自动根据src去加载代码</p>
</li>
</ol>
<p>在设置加载路径也就是script的src属性时，用到了<code>jsonpScriptSrc(chunkId)</code>这个方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonpScriptSrc</span>(<span class="params">chunkId</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> __webpack_require__.p + <span class="string">&quot;&quot;</span> + (&#123;&#125;[chunkId]||chunkId) + <span class="string">&quot;.bundlle.js&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法很简单，就是根据传进来的chunkId生成对应的chunk路径，这里的<code>__webpack__require__.p</code>就是webpack配置中的<code>publicPath</code>。我们这个例子中没有设置<code>publicPath</code>，所以<code>src</code>值为<code>0.bundle.js</code>。</p>
<p>所加载的0.bundle.js内容如下，也就是async.js打包后的内容：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="built_in">window</span>[<span class="string">&quot;webpackJsonp&quot;</span>] = <span class="built_in">window</span>[<span class="string">&quot;webpackJsonp&quot;</span>] || []).push([[<span class="number">0</span>],&#123;</span><br><span class="line"><span class="string">&quot;./src/asyncc.js&quot;</span>:(<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">module</span>, __webpack_exports__, __webpack_require__</span>) </span>&#123;</span><br><span class="line"><span class="meta">    &quot;use strict&quot;</span>;</span><br><span class="line">    __webpack_require__.r(__webpack_exports__);</span><br><span class="line">    <span class="keyword">var</span> text = <span class="string">&#x27;async&#x27;</span>;</span><br><span class="line">    __webpack_exports__[<span class="string">&quot;default&quot;</span>] = (text);</span><br><span class="line"></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;]);</span><br></pre></td></tr></table></figure>

<p>这段代码中先是用到了<code>window.webpackJsonp.push</code>方法，这个方法在主打包文件index.bundle.js中可以找到定义：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jsonpArray = <span class="built_in">window</span>[<span class="string">&quot;webpackJsonp&quot;</span>] = <span class="built_in">window</span>[<span class="string">&quot;webpackJsonp&quot;</span>] || [];</span><br><span class="line"><span class="keyword">var</span> oldJsonpFunction = jsonpArray.push.bind(jsonpArray);</span><br><span class="line">jsonpArray.push = webpackJsonpCallback;</span><br></pre></td></tr></table></figure>

<p>所以<code>window.webpackJsonp.push</code>其实就是<code>webpackJsonpCallback()</code>方法，方法内容如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">webpackJsonpCallback</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> chunkIds = data[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">var</span> moreModules = data[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> moduleId, chunkId, i = <span class="number">0</span>, resolves = [];</span><br><span class="line">  <span class="keyword">for</span>(;i &lt; chunkIds.length; i++) &#123;</span><br><span class="line">    chunkId = chunkIds[i];</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Object</span>.prototype.hasOwnProperty.call(installedChunks, chunkId) &amp;&amp; installedChunks[chunkId]) &#123;</span><br><span class="line">      <span class="comment">// 收集各模块的resolve方法，供后面统一处理</span></span><br><span class="line">      resolves.push(installedChunks[chunkId][<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    installedChunks[chunkId] = <span class="number">0</span>; <span class="comment">// 加载完成后，对应模块在installedChunks中的值为0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将加载的模块添加到modules对象上</span></span><br><span class="line">  <span class="keyword">for</span>(moduleId <span class="keyword">in</span> moreModules) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Object</span>.prototype.hasOwnProperty.call(moreModules, moduleId)) &#123;</span><br><span class="line">      modules[moduleId] = moreModules[moduleId]; <span class="comment">// 将异步加载到的模块放到modules中</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(parentJsonpFunction) parentJsonpFunction(data);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(resolves.length) &#123;</span><br><span class="line">    resolves.shift()(); <span class="comment">// 执行resolve，结束promise</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>结合0.bundle.js代码，<code>webpackJsonCallback()</code>主要作用有三个：</p>
<ol>
<li>将异步加载到的模块对象放到<code>modules</code>变量中</li>
</ol>
<p>modules是外层函数的入参，这个不要忘了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(moduleId <span class="keyword">in</span> moreModules) &#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">Object</span>.prototype.hasOwnProperty.call(moreModules, moduleId)) &#123;</span><br><span class="line">    modules[moduleId] = moreModules[moduleId]; <span class="comment">// 将异步加载到的模块放到modules中</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>将已经加载的模块标记为已加载</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">installedChunks[chunkId] = <span class="number">0</span>; <span class="comment">// 加载完成后，对应模块在installedChunks中的值为0</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>将异步模块对应的promise结束掉</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">resolves.push(installedChunks[chunkId][<span class="number">0</span>]);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">while</span>(resolves.length) &#123;</span><br><span class="line">  resolves.shift()(); <span class="comment">// 执行resolve，结束promise</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以注意到，在结束promise时，并没有把模块内容resolve出去，所以这个模块内容是如何被引入的（每个模块都是一个方法，方法要被执行模块内容才能被引入）？</p>
<p>上面提到，<code>webpackJsonCallback()</code>这个方法会将模块对象加入到<code>modules</code>对象中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(moduleId <span class="keyword">in</span> moreModules) &#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">Object</span>.prototype.hasOwnProperty.call(moreModules, moduleId)) &#123;</span><br><span class="line">    modules[moduleId] = moreModules[moduleId]; <span class="comment">// 将异步加载到的模块放到modules中</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>既然放进去了，那肯定有用到的地方。</p>
<p>回到index.bundle.js中，拖到代码最下面加载async.js部分：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.show) &#123;</span><br><span class="line">  __webpack_require__.e(<span class="comment">/*! import() */</span> <span class="number">0</span>).</span><br><span class="line">   then(__webpack_require__.bind(<span class="literal">null</span>, <span class="string">&quot;./src/async.js&quot;</span>)).</span><br><span class="line">   then(<span class="function"><span class="keyword">function</span> (<span class="params">_ref</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> text = _ref[<span class="string">&quot;default&quot;</span>];</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">console</span>.log(text);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>可以看到，在异步文件加载结束后（就是promise结束后）接着调用的是<code>__webpack__require__(&#39;./src/async.js&#39;)</code>方法，入参是<code>&#39;./src/async.js&#39;</code>，接下里的事情就很明显了：<code>__webpack__require__()</code>方法根据moduleId—-<code>./src/async.js</code>去modules中加载模块，运行模块内容，接着返回模块要导出的内容。因为这里<code>__webpack__require__</code>方法是作为<code>then()</code>方法的第一个参数运行的，所以其返回内容可以被紧跟后面的<code>.then()</code>方法捕捉到，在后面的<code>.then()</code>方法中执行的就是源码中需要在async.js加载完成才能运行的代码了。</p>
<p><img src="../img/%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD.jpeg"></p>
<p>至此，整个异步代码加载完毕。</p>
<p><img src="../img/%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B.jpg" alt="异步加载流程"></p>
<p>一句话总结下就是：所谓的动态加载js，其实是通过script标签来实现的。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2021/12/10/webpack%E6%98%AF%E5%A6%82%E4%BD%95%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9D%97%E7%9A%84%EF%BC%88%E4%B8%89%EF%BC%89/" class="prev">上一篇</a><a href="/2021/12/10/webpack%E6%98%AF%E5%A6%82%E4%BD%95%E5%8A%A0%E8%BD%BD%E6%A8%A1%E5%9D%97%E7%9A%84%EF%BC%88%E4%B8%80%EF%BC%89/" class="next">下一篇</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'seansun';
var disqus_identifier = '2021/12/10/webpack是如何加载模块的（二）/';
var disqus_title = 'webpack是如何加载模块的（二）：异步模块的加载';
var disqus_url = 'http://mengfansheng.com/2021/12/10/webpack是如何加载模块的（二）/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//seansun.disqus.com/count.js" async></script><div class="copyright"><p>© 2015 - 2021 <a href="http://mengfansheng.com">孟凡胜</a>, <a href="http://www.beian.miit.gov.cn" target="_blank">苏ICP备17022623号</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>